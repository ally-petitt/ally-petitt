<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Linux on Ally Petitt</title>
    <link>https://ally-petitt.com/tags/linux/</link>
    <description>Recent content in Linux on Ally Petitt</description>
    <generator>Hugo -- 0.125.4</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Dec 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ally-petitt.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stealthy Exploit Opens Door for Pre-Compilation Code Execution</title>
      <link>https://ally-petitt.com/posts/2023-12-02_stealthy-exploit-opens-door-for-pre-compilation-code-execution-17a57b9585cb/</link>
      <pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://ally-petitt.com/posts/2023-12-02_stealthy-exploit-opens-door-for-pre-compilation-code-execution-17a57b9585cb/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*XwuUEqGz-1xT_v_j.jpg&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://img.rasset.ie/001babea-1600.jpg&#34;&gt;https://img.rasset.ie/001babea-1600.jpg&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Linux users often take pride in their ability to compile their own code. In spite of this, a subtle yet critical attack vector has existed for over 20 years with high potential impact when exploited. Cleverly disguised within the &lt;code&gt;configure.ac&lt;/code&gt; file, this attack vector allows malicious actors to execute code on your system before the compilation process even begins.&lt;/p&gt;
&lt;p&gt;While the absence of known exploits may lull users into a false sense of security, it is precisely this lack of awareness that makes this attack vector dangerous, increasing the chances of successful and large-scale exploitation.&lt;/p&gt;
&lt;p&gt;The security concern that I am referring to is the ability to execute arbitrary code through &lt;code&gt;autoconf&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;what-is-autoconf&#34;&gt;What is Autoconf?&lt;/h1&gt;
&lt;p&gt;Traditionally, developers have used a &lt;a href=&#34;https://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html&#34;&gt;build system&lt;/a&gt; in order to distribute software packages that are easy for clients to compile. These build steps are specified in a Makefile.&lt;/p&gt;
&lt;p&gt;Different systems have different requirements. Sometimes, they require different flags to be set during compilation and sometimes the compiler is referred to by a different name. With such a diverse array of systems and configurations to cater to, Autoconf was offered as a solution.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*WhDuZ1uRN5oHHeR9&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;GNU Logo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Autoconf is a crucial part of the GNU Autotools project and it ensures that packages are portable across different systems. It accomplishes this through macros from the M4 programming language to create a shell script that configures software source code packages for the respective system (see the &lt;a href=&#34;https://github.com/autotools-mirror/autoconf&#34;&gt;README&lt;/a&gt; for more information).&lt;/p&gt;
&lt;h1 id=&#34;how-does-autoconfwork&#34;&gt;How Does Autoconf Work?&lt;/h1&gt;
&lt;p&gt;Autoconf is one of the first commands executed when building a package that follows &lt;a href=&#34;https://www.gnu.org/prep/standards/standards.html&#34;&gt;GNU Coding Standards&lt;/a&gt; (which is a lot of packages). If not called directly, it is often included in an &lt;code&gt;autogen.sh&lt;/code&gt; script. The program uses instructions from a &lt;code&gt;configure.ac&lt;/code&gt; file to generate a dynamic &lt;code&gt;configure&lt;/code&gt;bash script that is responsible for matching the libraries on the system to those required in the program.&lt;/p&gt;
&lt;h1 id=&#34;the-securityconcern&#34;&gt;The Security Concern&lt;/h1&gt;
&lt;p&gt;Because Autoconf interprets user-controlled input through the &lt;code&gt;configure.ac&lt;/code&gt; file, it is possible to insert malicious code that gets executed upon the running the generated &lt;code&gt;configure&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Furthermore, and increasingly concerning, is the possibility of obtaining code execution upon execution of the &lt;code&gt;autoconf&lt;/code&gt; command- before the generated &lt;code&gt;configure&lt;/code&gt; file is even ran. This means one less step in order to pwn a computer.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*Hgtdvi95rRshZbBM.png&#34; alt=&#34;&#34;  /&gt;

For example, hackers can embed a malicious payload within the &lt;code&gt;configure.ac&lt;/code&gt; file and when an unsuspecting Linux user begins building the package, the attacker-controlled code would be executed on the system.&lt;/p&gt;
&lt;p&gt;This can be abused to perform targeted cyberattacks on developers, general Linux users, security researchers, and more if the supply chain is compromised. Additionally, because this is not well-known, modern code-scanning and SAST solutions often fail to include checks for malicious code within &lt;code&gt;configure.ac&lt;/code&gt;, decreasing the chance of detection.&lt;/p&gt;
&lt;p&gt;I discuss exactly how to exploit this in my &lt;a href=&#34;https://github.com/ally-petitt/autoconf-code-execution&#34;&gt;Proof-of-Concept&lt;/a&gt; on GitHub, which was published after receiving permission from the Autoconf maintainers to publicly disclose my concerns.&lt;/p&gt;
&lt;h1 id=&#34;how-hard-was-this-tofind&#34;&gt;How Hard Was This To Find?&lt;/h1&gt;
&lt;p&gt;I want to briefly explain the ease with which I was able to uncover this potentially dangerous functionality. First, I identified the programming language being used was M4, so I read &lt;a href=&#34;https://mbreen.com/m4.html&#34;&gt;core notes&lt;/a&gt; for approximately 30 minutes to get a high-level overview of the language.&lt;/p&gt;
&lt;p&gt;After experimenting with the functionality and realizing that it was possible to embed bash code in the created &lt;code&gt;configure&lt;/code&gt; script, I wondered if I could take it a step further and get code execution from running &lt;code&gt;autoconf&lt;/code&gt; alone.&lt;/p&gt;
&lt;p&gt;Within 2 hours of combing through the source code to learn how the application works, I identified 3 potential locations for code to be executed. I then created a &lt;a href=&#34;https://github.com/ally-petitt/autoconf-code-execution&#34;&gt;PoC&lt;/a&gt; to submit in a bug report to the Autoconf maintainers.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*H4i_I34WTV0KbZE5&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://seeklogo.com/images/M/m4-logo-88B85DB5FB-seeklogo.com.png&#34;&gt;https://seeklogo.com/images/M/m4-logo-88B85DB5FB-seeklogo.com.png&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;My findings were low-hanging fruits and I suspect they have only gone this long without being abused because of the learning curve to understand M4. As you will see in the next segment, I am far from the first to know of this functionality.&lt;/p&gt;
&lt;h1 id=&#34;autoconfs-response&#34;&gt;Autoconf’s Response&lt;/h1&gt;
&lt;p&gt;Since 2/3 of my concerns came from a segment of legacy code that has been unused since the year 2000, one of the maintainers removed the macro in &lt;a href=&#34;https://git.savannah.gnu.org/cgit/autoconf.git/commit/?id=11d8824daada20055c855f46ad7c45237c1ff455&#34;&gt;this commit&lt;/a&gt; and thanked me for bringing the unused code snippets to their attention.&lt;/p&gt;
&lt;p&gt;They explained to me that there were plenty of opportunities to execute code when using Autoconf and that the ability to invoke macros such as &lt;code&gt;m4_syscmd&lt;/code&gt;, allowing for code execution, was a conscious design decision as many of their users rely on that functionality. In fact, it is common for &lt;code&gt;m4_syscmd&lt;/code&gt; to be used to run commands such as &lt;code&gt;git describe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another of the points in my PoC was that they included a macro that executed the &lt;code&gt;cat&lt;/code&gt; command without an absolute path. This made the program vulnerable to the modification of a $PATH environmental variable which could lead to execute arbitrary code execution and privilege escalation under the correct circumstances.&lt;/p&gt;
&lt;p&gt;The maintainers explained that adding an absolute path to the binary would break Nix, Guix, and more. They made the assumption that Autoconf is being run in an environment with a secure $PATH within a sandbox, which is consistent with best practices. However, I have strong doubts that the majority of users actually follow these precautions.&lt;/p&gt;
&lt;h1 id=&#34;implications&#34;&gt;Implications&lt;/h1&gt;
&lt;p&gt;I want to be clear that I respect the maintainers and the effort and time they have put into creating a tool that we have all benefited from. The ability to execute OS commands is not inherently dangerous, but when abused it can certainly have security implications.&lt;/p&gt;
&lt;p&gt;Given the reliance on &lt;code&gt;m4_syscmd&lt;/code&gt; by Autoconf’s clientele, it is clear to me that the maintainers have no plans of removing the functionality. The ability to execute arbitrary code upon running &lt;code&gt;autoconf&lt;/code&gt; will remain in the foreseeable future, making it an even more attractive attack vector for adversaries.&lt;/p&gt;
&lt;p&gt;In fact, the manner in which this functionality is built-in is reminiscent of attack techniques displayed in &lt;a href=&#34;https://gtfobins.github.io/&#34;&gt;GTFObins&lt;/a&gt;, which are often used for privilege escalation.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The ability to run commands from Autoconf is a feature, not a bug. However, it is a feature that can be abused in a way that very few people are aware of. And when exploited strategically, this can lead to the infection or damage of thousands of devices.&lt;/p&gt;
&lt;p&gt;I hope that in writing this, I was able to bring awareness to open-source users on the potential dangers of configuring untrusted applications. If you have any questions, concerns, or criticisms on this article, feel free to message me on &lt;a href=&#34;https://www.linkedin.com/in/ally-petitt/&#34;&gt;LinkedIn&lt;/a&gt; and I will be happy to discuss them with you.&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>5 Ways I Found Your Deleted Files</title>
      <link>https://ally-petitt.com/posts/2023-05-13_5-ways-i-found-your-deleted-files-492407dbd467/</link>
      <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate>
      <guid>https://ally-petitt.com/posts/2023-05-13_5-ways-i-found-your-deleted-files-492407dbd467/</guid>
      <description>&lt;h2 id=&#34;computer-forensics-for-filerecovery&#34;&gt;Computer Forensics for File Recovery&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*MnBiAcwiwaFGOOAe.jpg&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://edgy.app/wp-content/uploads/2018/04/dataleakhackerGorodenkoff-970x546.jpg&#34;&gt;https://edgy.app/wp-content/uploads/2018/04/dataleakhackerGorodenkoff-970x546.jpg&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;When a file is “deleted”, its contents aren’t typically erased from the storage device that it was stored on. More often than not, the blocks that stored the file are marked as unallocated and the filesystem pointers are removed from it. The implication is that the file still exists on the disk until it is overwritten.&lt;/p&gt;
&lt;p&gt;There are many methods to recovering the raw, unallocated data. &lt;a href=&#34;https://forensics.wiki/tools_data_recovery/&#34;&gt;This website&lt;/a&gt; lists many tools that can be used for file recovery in different scenarios. In this article, I’ll be walking through 5 different tools that can be used to recover data.&lt;/p&gt;
&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;
&lt;p&gt;I’ll be using doing forensic analysis on a drive that I created and attached to my Kali Linux VM. To see how this is done, you can reference &lt;a href=&#34;https://opensource.com/article/19/4/create-filesystem-linux-partition&#34;&gt;this article&lt;/a&gt;. On this drive, I saved and then deleted an image file and text file.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*HRHkhSM5bBjI9ouCYNpU4w.png&#34; alt=&#34;Image of commands I used to set up file system for forensic analysis&#34;  /&gt;

I’ll start by doing general enumeration on the disk image. Then, I’ll showcase a variety of file recovery techniques used by forensic analysts that allowed me to recover the deleted files. Many of the tools used will be from the &lt;a href=&#34;http://sleuthkit.org/sleuthkit&#34;&gt;Sleuth Kit&lt;/a&gt; (TSK).&lt;/p&gt;
&lt;p&gt;Before starting, I’ll unmount the filesystem, create a duplicate of it, remove write permissions from the duplicate, and verify the integrity of the duplicate against the original hash of &lt;code&gt;/dev/sdb&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cd ../ &amp;amp;&amp;amp; umount /mnt/secret # unmount /mnt/secret  
  
$ dd if=/dev/sdb of=/home/kali/forensics/sdb.img # copy /dev/sdb into sdb.img  
22286+0 records in  
22286+0 records out  
11410432 bytes (11 MB, 11 MiB) copied, 0.0412053 s, 277 MB/s  
  
$ chmod a-w /home/kali/forensics/sdb.img # remove write access to the image  
   
$ md5sum /home/kali/forensics/sdb.img /dev/sdb  
6c49fb21916d59e0df69453959392e23 /home/kali/forensics/sdb.img  
6c49fb21916d59e0df69453959392e23 /dev/sdb
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;enumeration&#34;&gt;Enumeration&lt;/h1&gt;
&lt;h2 id=&#34;image-analysis&#34;&gt;Image Analysis&lt;/h2&gt;
&lt;p&gt;Using the &lt;code&gt;file&lt;/code&gt; command reveals that the image uses an ext4 file system.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*4gowWgQfJ4J1FXwjFHjhQg.png&#34; alt=&#34;&#34;  /&gt;

Furthermore, the &lt;code&gt;stat&lt;/code&gt; command displays information about the image such as its size, time stamps, and block details.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*_T8VXPuyfnuQ7Rm5WNIOsQ.png&#34; alt=&#34;output of the stat command&#34;  /&gt;

With the information that the image uses ext4, the &lt;code&gt;fsstat&lt;/code&gt; command can be used to extract more detailed information about the file system, metadata, content data, and block groups.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ fsstat -f ext4 sdb.img   
FILE SYSTEM INFORMATION  
--------------------------------------------  
File System Type: Ext4  
Volume Name:   
Volume ID: dc8a4fb36dce8eabee4c51cf01c2d52a  
  
Last Written at: 2023-05-09 22:35:31 (EDT)  
Last Checked at: 2023-05-09 22:23:26 (EDT)  
  
Last Mounted at: 2023-05-09 22:24:27 (EDT)  
Unmounted properly  
Last mounted on: /mnt/secret  
  
Source OS: Linux  
Dynamic Structure  
Compat Features: Journal, Ext Attributes, Resize Inode, Dir Index  
InCompat Features: Filetype, Extents, 64bit, Flexible Block Groups,   
Read Only Compat Features: Sparse Super, Large File, Huge File, Extra Inode Size  
  
Journal ID: 00  
Journal Inode: 8  
  
METADATA INFORMATION  
--------------------------------------------  
Inode Range: 1 - 2785  
Root Directory: 2  
Free Inodes: 2773  
Inode Size: 256  
  
CONTENT INFORMATION  
--------------------------------------------  
Block Groups Per Flex Group: 16  
Block Range: 0 - 11139  
Block Size: 1024  
Reserved Blocks Before Block Groups: 1  
Free Blocks: 9223  
  
BLOCK GROUP INFORMATION  
--------------------------------------------  
Number of Block Groups: 2  
Inodes per group: 1392  
Blocks per group: 8192  
  
Group: 0:  
 Block Group Flags: [INODE\_ZEROED]   
 Inode Range: 1 - 1392  
 Block Range: 1 - 8192  
 Layout:  
 Super Block: 1 - 1  
 Group Descriptor Table: 2 - 2  
 Group Descriptor Growth Blocks: 3 - 89  
 Data bitmap: 90 - 90  
 Inode bitmap: 92 - 92  
 Inode Table: 94 - 441  
 Uninit Data Bitmaps: 92 - 105  
 Uninit Inode Bitmaps: 94 - 107  
 Uninit Inode Table: 790 - 5661  
 Data Blocks: 5690 - 8192  
 Free Inodes: 1381 (99%)  
 Free Blocks: 6365 (77%)  
 Total Directories: 2  
 Stored Checksum: 0x7DEB  
  
Group: 1:  
 Block Group Flags: [INODE\_UNINIT, INODE\_ZEROED]   
 Inode Range: 1393 - 2784  
 Block Range: 8193 - 11139  
 Layout:  
 Super Block: 8193 - 8193  
 Group Descriptor Table: 8194 - 8194  
 Group Descriptor Growth Blocks: 8195 - 8281  
 Data bitmap: 91 - 91  
 Inode bitmap: 93 - 93  
 Inode Table: 442 - 789  
 Data Blocks: 8282 - 11139  
 Free Inodes: 1392 (100%)  
 Free Blocks: 2858 (96%)  
 Total Directories: 0  
 Stored Checksum: 0xDFA7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Based on this output, it is clear that the block size is 1024 bits, there are 1113 total blocks, and there are 2785 inodes.&lt;/p&gt;
&lt;p&gt;In addition, &lt;code&gt;parted&lt;/code&gt; can be used to find more information on the partition table, which can be useful when using scalpel.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*EAJIlLWQ5g3rEgqc5nPNbQ.png&#34; alt=&#34;&#34;  /&gt;

Finally, running &lt;code&gt;strings&lt;/code&gt; on the image gives more insight as to what is in the filesystem. It appears that my &lt;code&gt;secret.txt&lt;/code&gt; file with the contents &lt;code&gt;Hello World&lt;/code&gt; is appearing from the &lt;code&gt;strings&lt;/code&gt; command in addition to a failed image download attempt.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*hINgjWeGy7ttVHl1qDs1EQ.png&#34; alt=&#34;&#34;  /&gt;

In the command &lt;code&gt;strings -a --radix=d sdb.img&lt;/code&gt;, &lt;code&gt;-a&lt;/code&gt; is an option to scan the entire file and &lt;code&gt;--radix=d&lt;/code&gt; tells &lt;code&gt;strings&lt;/code&gt; to show the offset that the string was found at in base 10.&lt;/p&gt;
&lt;h2 id=&#34;analyzing-thefiles&#34;&gt;Analyzing the Files&lt;/h2&gt;
&lt;p&gt;This particular image does not have any files currently in it aside from deleted files, so there isn’t much information to gain from mounting it and analyzing the files. In cases where it is desireable to do so, the following command can be used:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ mount -o ro,loop,noexec,noatime sdb.img
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Below, I’ll explain what the options do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;: sets the options for mounting &lt;code&gt;sdb.img&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ro&lt;/strong&gt;: an option to mount the file system as being read-only&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;loop&lt;/strong&gt;: mount the file system on a loop device&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;noexec&lt;/strong&gt;: disallow execution&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;noatime&lt;/strong&gt;: don’t change the access time of the files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can then continue to run &lt;code&gt;file&lt;/code&gt; on the files within the mounted loop device and save their md5 hashes to verify integrity.&lt;/p&gt;
&lt;h1 id=&#34;recovering-thefiles&#34;&gt;Recovering the Files&lt;/h1&gt;
&lt;h2 id=&#34;method-1-using-sleuthkithttpsleuthkitorgsleuthkit&#34;&gt;Method 1: Using &lt;a href=&#34;http://sleuthkit.org/sleuthkit/&#34;&gt;Sleuth Kit&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Often, if you have deleted files, they may be displayed with &lt;code&gt;fls sdb.img&lt;/code&gt;, enumerated with &lt;code&gt;istat -o &amp;lt;offset&amp;gt; sdb.img &amp;lt;inode_number&amp;gt;&lt;/code&gt;, and recovered with &lt;code&gt;icat -o &amp;lt;offset&amp;gt; sdb.img &amp;lt;inode_number&amp;gt;&lt;/code&gt;. An example of the latter 2 steps are shown in the screenshot below.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*mc44fgKV8os0qCVpYYZiJQ.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://www.therootuser.com/wp-content/uploads/2017/11/Screenshot-2017-11-07-17.27.58.png&#34;&gt;https://www.therootuser.com/wp-content/uploads/2017/11/Screenshot-2017-11-07-17.27.58.png&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This does not appear to be the case for me, however. My deleted files are not appearing from the &lt;code&gt;fls&lt;/code&gt; command. Instead, I see a variable called &lt;code&gt;$OrphanFiles&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*hQXtm0cZ7wge3IgQlexR-Q.png&#34; alt=&#34;&#34;  /&gt;

&lt;code&gt;$OrphanFiles&lt;/code&gt; are files that still exist in the image, but are no longer able to be accessed from the root directory. &lt;code&gt;$OrphanFiles&lt;/code&gt; is not an actual directory on the image, it is Sleuth Kit’s virtual way to demonstrate that the file metadata still exists (&lt;a href=&#34;https://wiki.sleuthkit.org/index.php?title=Orphan_Files&#34;&gt;read more&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;To recover these orphan files, I will attempt a few techniques starting with &lt;code&gt;extundelete&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;method-2-extundeletehttpsextundeletesourceforgenet&#34;&gt;Method 2: &lt;a href=&#34;https://extundelete.sourceforge.net/&#34;&gt;Extundelete&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This tool can be used to recover files on ext3 and ext4 filesystems. I was having some difficulties with the build from &lt;code&gt;apt&lt;/code&gt;, so I build the program from source with the following commands to it working again:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apt update &amp;amp;&amp;amp; apt install -y libext2fs-dev   
git clone https://github.com/cherojeong/extundelete.git  
./configure  
make  
src/extundelete --restore-all /path/to/image.img
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;os &amp;lt;&amp;lt; “Directory ACL: “ &amp;lt;&amp;lt; inode.i_dir_acl &amp;lt;&amp;lt; std::endl;&lt;/code&gt; with &lt;code&gt;os &amp;lt;&amp;lt; “Directory ACL: “ &amp;lt;&amp;lt; inode.i_file_acl &amp;lt;&amp;lt; std::endl;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The command &lt;code&gt;extundelete --restore-all sdb.img&lt;/code&gt; can be used to recover files.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*Ipv-ABMSCpXNtc6PZT5zqQ.png&#34; alt=&#34;&#34;  /&gt;

As you can see in the screenshot above, the tool was unsuccessful in recovering the orphan files. This is still a viable option that can work in many scenarios which is why I decided to include it in this article.&lt;/p&gt;
&lt;p&gt;I’m not giving up yet. We’ll try again!&lt;/p&gt;
&lt;h2 id=&#34;method-3testdiskhttpswwwcgsecurityorgwikitestdisk&#34;&gt;Method 3: &lt;a href=&#34;https://www.cgsecurity.org/wiki/TestDisk&#34;&gt;TestDisk&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;.tar.bz&lt;/code&gt; file can be downloaded &lt;a href=&#34;https://www.cgsecurity.org/wiki/TestDisk_Download&#34;&gt;here&lt;/a&gt;. I’m using version 7.2. Note that in order for &lt;code&gt;TestDisk&lt;/code&gt; to work, you must run it in the download directory. Otherwise you might get an error like &lt;code&gt;*** Error in &lt;/code&gt;/path/to/testdisk-7.2-WIP/photorec_static&amp;rsquo;: malloc(): memory corruption: 0x0000000002617d29 ***`.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# extract and run the file  
tar -xf testdisk-7.2-WIP.linux26-x86\_64.tar.bz2  
cd testdisk-7.2-WIP  
./photorec\_static /path/to/sdb.img /log 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A help menu will appear. I’ll first select the image that I want to work with.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*vEuqI7RnAWsvLfrH9n88Pw.png&#34; alt=&#34;&#34;  /&gt;

Then, I select the option for the partition table for the media. Mine does not have one, so I choose “None”. I verified that this was the only option that was able to list files for me.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*c5iJeI2oyLMdmRu_bBD5Qg.png&#34; alt=&#34;&#34;  /&gt;

After this, I navigate to the “List” option at the bottom of the terminal and press &lt;code&gt;Enter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*jl17is949wOoNF0JEzBcIg.png&#34; alt=&#34;&#34;  /&gt;

This leads me to the listing of the files on the image with the successfully recovered ones in &lt;strong&gt;red&lt;/strong&gt; text.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*yYQEslxR1RWkUbkEX743Bg.png&#34; alt=&#34;&#34;  /&gt;

As you can see in the screenshot, there are no new files there listed in red. This means that &lt;code&gt;TestDisk&lt;/code&gt; was unsuccessful in recovering the deleted files.&lt;/p&gt;
&lt;p&gt;It’s okay, I still got a few more tricks up my sleeve.&lt;/p&gt;
&lt;h2 id=&#34;method-4foremosthttpssourceforgenetprojectsforemost&#34;&gt;Method 4: &lt;a href=&#34;https://sourceforge.net/projects/foremost/&#34;&gt;Foremost&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Foremost can be installed with &lt;code&gt;apt&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install foremost
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This tool uses a technique known as &lt;strong&gt;file carving&lt;/strong&gt; which involves searching through the raw data on a disk and carving out the values between the header and/or footer of the file.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*ayacIY6WQdxAYksd_nwT8g.png&#34; alt=&#34;&#34;  /&gt;

Alas, we were able to recover a deleted image file from the drive with &lt;code&gt;foremost -t jpeg -o recovered-files -i sdb.img&lt;/code&gt;. The recovered image renders as expected in the Image Viewer. What a pretty camp fire.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*kA2aubO7prDBFW9Xx0cGvQ.png&#34; alt=&#34;&#34;  /&gt;

The fact that this worked while the previous 3 methods did not further demonstrates that different tools and techniques will be more effective at data recovery in different scenarios.&lt;/p&gt;
&lt;p&gt;It’s also worth mentioning that you can edit the &lt;code&gt;/etc/foremost.conf&lt;/code&gt; file to contain your own custom headers and footers for the file you are looking for. Modifying these values will be explored in the next and final method.&lt;/p&gt;
&lt;h2 id=&#34;method-5scalpelhttpsgithubcomsleuthkitscalpel&#34;&gt;Method 5: &lt;a href=&#34;https://github.com/sleuthkit/scalpel&#34;&gt;Scalpel&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Scalpel is much like Foremost with added flexibility. You are not as limited on the file types and headers, although there is a way to modify foremost to have the same customization that scalpel provides.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install scalpel  
cp /etc/scalpel/scalpel.conf .  
vim scalpel.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I’ll edit the config with the bit of background information that I have. I know that I’m attempting to recover a JPEG file and I also know that there was a text file that began with the word “Hello”. By using &lt;code&gt;xxd&lt;/code&gt;, I can determine the file headers for a &lt;code&gt;.txt&lt;/code&gt; file starting with the word “Hello”. In this case, it would be &lt;code&gt;\x48\x65\x6c\x6c\x6f&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ echo -n Hello | xxd   
00000000: 4865 6c6c 6f Hello.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will use this information to update the &lt;code&gt;scalpel.conf&lt;/code&gt; file in &lt;code&gt;vim&lt;/code&gt;. As explained in the comments at the top of the config file, the first column indicates the file extension. The second is whether the header and footer are case sensitive, the third is the header in hexadecimal bytes, the fourth column is an optional footer, and the fifth column is an optional parameter to search backwards from the header rather than just forward.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*Y6kTU1JxILxivTOYbHN5tQ.png&#34; alt=&#34;&#34;  /&gt;

With these options set, &lt;code&gt;scalpel&lt;/code&gt; can now be ran to extract these files from the drive.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;scalpel -o recovered-files\_scalpel -c scalpel.conf sdb.img
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*O3huS4-S2BausvT-s2KiYw.png&#34; alt=&#34;&#34;  /&gt;

It appears that the text file was successfully recovered.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*jASCyrkTBYVfhWQxZkk3lg.png&#34; alt=&#34;&#34;  /&gt;

The image was recovered as well.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*5ixUUenRR50lIavpZ0oyIw.png&#34; alt=&#34;&#34;  /&gt;

Conclusion&lt;/h1&gt;
&lt;p&gt;There’s many ways to achieve the same outcome. The different tools showcased here have their specific applications where they perform best. Even though not all the methods outlined here worked for my particular situation, that doesn’t mean they won’t work for you. There are many factors that determine whether file recovery will be successful including the partitioning table type, how long it has been since they were deleted, the size of the file (smaller files are more likely to be recovered), the health of the storage device, and the operations that have been done on the drive since deleting the files such as reformatting the drive.&lt;/p&gt;
&lt;p&gt;I hope that through reading this article, you were able to deepen your understanding of file recovery and gain practical knowledge that you can apply in the real world. Thanks for reading and I’ll see you next time.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>How to Encrypt a Drive in Linux</title>
      <link>https://ally-petitt.com/posts/2023-05-05_how-to-encrypt-a-drive-in-linux-83b3001744f4/</link>
      <pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate>
      <guid>https://ally-petitt.com/posts/2023-05-05_how-to-encrypt-a-drive-in-linux-83b3001744f4/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Hey everyone, this is a pretty quick article on LUKS drive encryption on Linux with the &lt;code&gt;cryptsetup&lt;/code&gt; library. By following the steps outlined here, you will be able to encrypt a drive, decrypt it, and mount it. This was done in a Kali Linux VM and commands may vary for other distributions.&lt;/p&gt;
&lt;p&gt;Disclaimer: This is not an area that I have much experience in so if details are inaccurate, I apologize in advance.&lt;/p&gt;
&lt;h2 id=&#34;creating-a-new-partition&#34;&gt;Creating a new partition&lt;/h2&gt;
&lt;p&gt;I’m using a virtual machine with 2 virtual hard disks.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*ao7i4G4xZFiEXNb2nX2-bQ.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;Demonstrating my disks with “lsblk -e7”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I’ll be using a tool called &lt;code&gt;parted&lt;/code&gt; to create a partition on &lt;code&gt;/dev/sdb&lt;/code&gt;. Historically, when a system uses the Master Boot Record (MBR) partition table, &lt;code&gt;fdisk&lt;/code&gt; is used to manage the partition. In this article, I’ll use &lt;code&gt;parted&lt;/code&gt; because of its usability in scripting and automation.&lt;/p&gt;
&lt;p&gt;I’ll start by listing the information of the drives.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;parted -s /dev/sdb print all
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*5w3JBHztlFmtojmfpSwqAg.png&#34; alt=&#34;&#34;  /&gt;

The output &lt;code&gt;msdos&lt;/code&gt; under &lt;code&gt;/dev/sda&lt;/code&gt;, indicates that &lt;code&gt;sda&lt;/code&gt; is using the MBR partition table. Learn more about partition table types &lt;a href=&#34;https://en.wikipedia.org/wiki/Disk_partitioning&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://wiki.archlinux.org/title/Partitioning&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I’ll now create the GPT partition table on &lt;code&gt;/dev/sdb&lt;/code&gt;. You’ll notice that after running the command, &lt;code&gt;/dev/sdb&lt;/code&gt; now appears as a &lt;code&gt;gpt&lt;/code&gt; partition table.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*tZM4UvgCMQXekmpmoDJumg.png&#34; alt=&#34;&#34;  /&gt;

I then create a partition on the disk with the ext4 file system.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*dbuTKtvJcQZI4cFNANRylQ.png&#34; alt=&#34;&#34;  /&gt;

The commands I used for this are below. The values for the start and ending offsets when creating the partitions can be expressed in both percentages and exact byte values. Reference the &lt;a href=&#34;https://linux.die.net/man/8/parted&#34;&gt;man page&lt;/a&gt; for more details.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;parted -s /dev/sdb mklabel gpt  
parted -s /dev/sdb mkpart primary ext4 0% 50MiB
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;encrypting-thedrive&#34;&gt;Encrypting the Drive&lt;/h2&gt;
&lt;p&gt;This demonstrates how to encrypt file system using LUKS. It is important to remember the passphrase that you enter while encrypting the partition because it is a key piece of information when decrypting the drive.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cryptsetup luksFormat /dev/sdb # encrypt /dev/sdb with luks
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;decrypting-thedrive&#34;&gt;Decrypting the Drive&lt;/h2&gt;
&lt;p&gt;You’ll need to do this before you’re able to mount and use the partition on the drive.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cryptsetup open /dev/sdb encrypted # open the encrypted drive as /dev/mapper/encrypted  
mkfs.ext4 /dev/mapper/encrypted # create a filesystem on the device (only needed the first time you open the encrypted drive)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;mounting-the-partition&#34;&gt;Mounting the Partition&lt;/h2&gt;
&lt;p&gt;In order to actually use the partition and the file system on it, we must mount it.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir -p /mnt/encrypted # prepare the mount point  
mount /dev/mapper/encrypted /mnt/encrypted # mount the decrypted filesystem on /mnt/encrypted
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;unmounting-the-partition&#34;&gt;Unmounting the Partition&lt;/h2&gt;
&lt;p&gt;When you’re done using the drive, you can unmount it.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;umount /mnt/encrypted 
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;closing-and-re-encrypting-the-partition&#34;&gt;Closing and Re-encrypting the Partition&lt;/h2&gt;
&lt;p&gt;In its unmounted state, it is still decrypted. To re-encrypt and close the drive, you can run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cryptsetup close /dev/mapper/encrypted
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;digging-deeper&#34;&gt;Digging Deeper&lt;/h1&gt;
&lt;p&gt;Because I’m a curious person, I’ll share with you some commands that you can use to get more information on the file system that you just created and other findings that I thought were interesting.&lt;/p&gt;
&lt;h2 id=&#34;file-systemmetadata&#34;&gt;File System Metadata&lt;/h2&gt;
&lt;p&gt;After decrypting the drive, you can view the metadata of your filesystem.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cryptsetup --type luks open /dev/sdb encrypted
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These are some commands that will give you infromation.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;df -hT /dev/mapper/encrypted  
tune2fs -l /dev/sdb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As shown in the screenshots, you’re able to view the number of inodes, the block count, block size, filesystem magic number, and much more.&lt;/p&gt;
&lt;h2 id=&#34;inodes&#34;&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*k6QJaeh0pBMsxnfbGk6Rog.png&#34; alt=&#34;&#34;  /&gt;

&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*BXNCkBoJaesaE0AfBZlOsQ.png&#34; alt=&#34;&#34;  /&gt;

Inodes&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inode&#34;&gt;Inodes&lt;/a&gt; are a data structure that contain information about files in the Linux filesystem. It contains metadata such as the block number that the file is located in on the hard drive, permissions, and file owner. In an ext4 filesystem, the number of inodes in is fixed, whereas in XFS and JFS, the number of inodes is dynamic. The result is that in ext4 filesystems where many inodes are used, such as in situations where many directories, symbolic links, and/or small files are made, an error message that the system is out of space may occur when there is plenty of space left. The reason for this is simply that the filesystem has no more available inodes to assign to new files. This is a relatively common occurence for mail servers that often hold many small files.&lt;/p&gt;
&lt;p&gt;The number of inodes on your system’s filesystems can be viewed with &lt;code&gt;df -hi&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*_TgsDD7BK_fPitV0J31ywg.png&#34; alt=&#34;&#34;  /&gt;

You can query the inode information on a specific file with the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls -il file
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*nBvEce088HNvxUbcz1cF7w.png&#34; alt=&#34;&#34;  /&gt;

The inode number is on the leftmost column of output. In this case, it is &lt;code&gt;131079&lt;/code&gt;. Additionally, you can see the read, write, and execute permissions on the file with the owner and group associated with it.&lt;/p&gt;
&lt;p&gt;As an alternative, you can search for the file that is associated with a specific inode with this command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;find / -inum 1234567 -ls
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*15DlndsZGVZ0Q9A3lAtXeg.png&#34; alt=&#34;&#34;  /&gt;

I was able to find the file &lt;code&gt;/tmp/test.txt&lt;/code&gt; that was associated with &lt;code&gt;131079&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;duplicating-the-encrypted-drive&#34;&gt;Duplicating the Encrypted Drive&lt;/h2&gt;
&lt;p&gt;This command can be used to create an exact duplicate of &lt;code&gt;/dev/sdb&lt;/code&gt; in &lt;code&gt;/media/sdb.img&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dd if=/dev/sdb of=/media/sdb.img
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;next-steps&#34;&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*hzoKv4rgFMHTAQtFFIcaYQ.png&#34; alt=&#34;&#34;  /&gt;

Next Steps&lt;/h1&gt;
&lt;p&gt;Moving forward, you can expand upon what was done in this article by implementing an added layer of abstraction and flexibility with &lt;a href=&#34;https://linuxconfig.org/linux-lvm-logical-volume-manager&#34;&gt;LVM&lt;/a&gt;. You can also continue to experiment with different ways of encrypting partitions such as those outlined in &lt;a href=&#34;https://www.baeldung.com/linux/encrypt-partition&#34;&gt;this article&lt;/a&gt;. There are many different ways to configure your system and I would encourage you to continue learning. Thank you for reading!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Digging into the Linux Secure Boot Process</title>
      <link>https://ally-petitt.com/posts/2023-04-29_digging-into-the-linux-secure-boot-process-9631a70b158b/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://ally-petitt.com/posts/2023-04-29_digging-into-the-linux-secure-boot-process-9631a70b158b/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*6T29Pwj4dMhQiPRW.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;Linux Penguin&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This article will begin with a high-level overview of the Ubuntu boot process and will continue to dig deeper into the role of SecureBoot in it when enabled. Some of the concepts I will be covering include shim, EFI variables, and MOKs. The information presented here was aggregated from the sources listed at the bottom of this article. Commands and example output will also be included to help present the topic in a more comprehensive way.&lt;/p&gt;
&lt;p&gt;Understanding the boot process along with SecureBoot is important because without adequate understanding of the inner-workings of a Linux system, it can be very easy to accidentally brick the system when attempting to enable settings such as SecureBoot. These are low-level operations that can do a lot of damage.&lt;/p&gt;
&lt;p&gt;I would encourage Windows users to reference &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot&#34;&gt;this documentation&lt;/a&gt; for Secure Boot information relating to Windows.&lt;/p&gt;
&lt;h2 id=&#34;typical-bootprocess&#34;&gt;Typical Boot Process&lt;/h2&gt;
&lt;p&gt;When an Ubuntu machine boots, it goes through &lt;a href=&#34;https://wiki.ubuntu.com/Booting&#34;&gt;4 main phases&lt;/a&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;BIOS phase&lt;/strong&gt;- firmware on motherboard, typically stored as a form of read only memory (ROM), contains code to initialize the hardware components of the computer and obtain the code for the bootloader.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bootloader phase&lt;/strong&gt;- loads the operating system into memory along with an inital ram disk filesystem (&lt;a href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/initrd.html&#34;&gt;initrd&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kernel phase&lt;/strong&gt;- the kernel executes the init script inside the initrd filesystem. This loads hardware drivers and mounts the root partition.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;System startup&lt;/strong&gt;- the operating system loads system daemons and services, sets up the network, mounts file systems, starts system logging, and performs other initialization tasks.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is common for a 512-bit partition to be present on Linux systems called the Master Boot Record (MBR). This partition contains the bootloader (GRUB, LILO, yaboot, or others) and boot records. This is one of the places that Linux can be booted from. Other locations include a bootloader from a storage device like USB flash drive or CDR or a bootloader that is transferred over the network such as with Preboot Execution Environment (&lt;a href=&#34;https://en.wikipedia.org/wiki/Preboot_Execution_Environment&#34;&gt;PXE&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id=&#34;secure-boot&#34;&gt;Secure Boot&lt;/h2&gt;
&lt;p&gt;Secure Boot is a security standard. When the computer is turned on, the Secure Boot process begins with firmware in the motherboard, which will check the cryptographic signatures of each of the boot files. This includes UEFI firmware drivers (aka optional ROMs), EFI applications, and the operating system. Once verified, the computer boots and the firmware gives control to the operating system.&lt;/p&gt;
&lt;h2 id=&#34;shim&#34;&gt;Shim&lt;/h2&gt;
&lt;p&gt;When enabling Secure Boot, it is important to understand shim. In the context of SecureBoot, a shim is a pre-bootloader program that is designed to work with Secure Boot firmware. It allows for bootloaders and kernel modules to be loaded and executed if they are not included in the Secure Boot database. In Ubuntu, the shim loader is pre-installed and signed by the Microsoft certificate authority.&lt;/p&gt;
&lt;p&gt;Secure Boot uses asymmetrical cryptography, meaning that a public and private key are used. The key pair can be generated by the user and the private key is used to sign all programs that are allowed to run, including the GRUB bootloader. The firmware on the BIOS or UEFI will use the public key to verify the checksums and signatures of programs before allowing them to execute.&lt;/p&gt;
&lt;p&gt;You can check the signatures of your own shim loader with the &lt;code&gt;sbverify&lt;/code&gt; command that comes with the &lt;code&gt;sbsigntool&lt;/code&gt; package.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# locate your shim binary  
$ SHIM=$(sudo find /boot/efi/EFI/ -iname &amp;#34;shim*&amp;#34; 2&amp;gt;/dev/null)  
$ sbverify $SHIM  
Signature verification OK
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;uefi-variables&#34;&gt;UEFI variables&lt;/h2&gt;
&lt;p&gt;Another concept to be familiar with is the UEFI variables which are stored in firmware non-volatile RAM (NV-RAM). These variables store various data such as boot order preferences, timeout values, network settings, storage device details, and Secure Boot settings. Each UEFI variable will have its own binary file under &lt;code&gt;/sys/firmware/efi/efivars/&lt;/code&gt;. The naming convention for these files is the variable name followed by the vendor GUID. For example,&lt;code&gt;SecureBoot-8be4df61–93ca-11d2-aa0d-00e098032b8c&lt;/code&gt;may be used to store whether Secure Boot is enabled (0x01) or disabled (0x00).&lt;/p&gt;
&lt;p&gt;You can view some of these variables by either listing the contents of &lt;code&gt;/sys/firmware/efi/efivars/&lt;/code&gt; or using the &lt;code&gt;[efivarfs](https://manpages.org/efivar)&lt;/code&gt; tool to list and read the values.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo apt-get install efivar   
$ sudo efivar -p -n 8be4df61-93ca-11d2-aa0d-00e098032b8c-SecureBoot 1 ⨯
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*NorYyiqugzWJsb0pbGlbmA.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;Example output of the above command&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In this particular example, the value of the UEFI variable &lt;code&gt;SecureBoot&lt;/code&gt; is 0x01, which indicates that it is currently enabled. Some of the other important variables for Secure Boot are the following:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;8be4df61-93ca-11d2-aa0d-00e098032b8c-PKDefault  
8be4df61-93ca-11d2-aa0d-00e098032b8c-KEKDefault  
8be4df61-93ca-11d2-aa0d-00e098032b8c-dbDefault  
8be4df61-93ca-11d2-aa0d-00e098032b8c-dbxDefault
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These values pertain to the key databases which are used to determine whether or not a module is safe to load.&lt;/p&gt;
&lt;h2 id=&#34;secure-boot-databases&#34;&gt;Secure Boot Databases&lt;/h2&gt;
&lt;p&gt;Secure Boot utilizes 4 key databases. You can read more about them in the &lt;a href=&#34;https://uefi.org/sites/default/files/resources/UEFI_Spec_2_9_2021_03_18.pdf&#34;&gt;official specifications&lt;/a&gt; or see a summary here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Allowed Signature Database (db)&lt;/strong&gt;- contains a list of cryptographic signatures that are allowed to load during the boot process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disallowed Signature Database (dbx)&lt;/strong&gt;- contains a list of the cryptographic signatures that are not allowed to be loaded during the boot process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Key Enrollment Key Database (KEK)&lt;/strong&gt;- contains the key exchange keys used to authenticate other databases.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Platform Key Database (PK)&lt;/strong&gt;- contains the public key that is used to verify the signature of any bootloader or firmware that has been signed with its corresponding private key. The recommended platform key on UEFI is RSA-2048.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The key databases essentially set the rules for which signatures are allowed to be loaded and which are not. This is important in Secure Boot because it helps to verify the integrity of modules before they are executed.&lt;/p&gt;
&lt;h2 id=&#34;machine-owner-keysmoks&#34;&gt;Machine Owner Keys (MOKs)&lt;/h2&gt;
&lt;p&gt;Another component of the boot process is Machine Owner Keys (MOKs). MOKs are an extra database of keys that can be managed by the user. This is separate from the certificate authority key that comes shipped with shim. They give the user more control over which modules can be loaded. For example, when a user enrolls a MOK on the system, the key associated with it is added to the allowed signature database (db). This means that any binary signed with that key will be trusted by the firmware during the boot process.&lt;/p&gt;
&lt;p&gt;These are typically located in the&lt;code&gt;/var/lib/shim-signed/mok/&lt;/code&gt; directory under the names &lt;code&gt;MOK.der&lt;/code&gt;, &lt;code&gt;MOK.pem&lt;/code&gt; or &lt;code&gt;MOK.priv&lt;/code&gt;. If you don’t have MOK keys and would like to generate them, the following commands can be used:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# mkdir -p /var/lib/shim-signed/mok/  
# cd /var/lib/shim-signed/mok/  
# openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -days 36500 -subj &amp;#34;/CN=My Name/&amp;#34;  
# openssl x509 -inform der -in MOK.der -out MOK.pem
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By default, shim provides a management utility called MokManager that can be used to, “enroll keys, remove trusted keys, enroll binary hashes and toggle Secure Boot validation at the shim level,” as described by the &lt;a href=&#34;https://wiki.ubuntu.com/UEFI/SecureBoot&#34;&gt;Ubuntu documentation&lt;/a&gt;. Note that a password is typically required when using the MokManager to authenticate the user that is using it.&lt;/p&gt;
&lt;p&gt;MokManager will help to properly configure the keys when key management is required. Once key management has been completed, the system will reboot to enable the key management changes. If things go well, it will continue to boot as expected without a MokManager screen.&lt;/p&gt;
&lt;h2 id=&#34;bootloader-configurations-and-information&#34;&gt;Bootloader Configurations and Information&lt;/h2&gt;
&lt;p&gt;You can futher investigate your Linux machine’s boot process. One way to do this is to view the &lt;code&gt;/proc/cmdline&lt;/code&gt; file. This contains the kernel boot command line arguments that were passed to the kernel during the boot process.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cat /proc/cmdline  
# example output  
BOOT\_IMAGE=/boot/vmlinuz-5.11.0-16-generic root=UUID=12345678-1234-1234-1234-1234567890AB ro quiet splash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This command will output the path to the kernel image file that is loaded by the bootloader via &lt;code&gt;BOOT_IMAGE&lt;/code&gt;. The &lt;code&gt;quiet splash&lt;/code&gt; option at the end is commonly used by the GRUB bootloader to specify to suppress verbose boot messages and display a graphical boot splash screen.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;kernel image&lt;/strong&gt; is a binary file of the operating system core. It contains contains the necessary code and data structures to boot the system, manage memory, handle input/output operations, and execute user programs. They can be used by the bootloader to start the OS. The name of the kernel image will typically represent its version and architecture. For instance, the kernel image &lt;code&gt;vmlinuz-5.4.0–1042-aws&lt;/code&gt; is version &lt;code&gt;5.4.0–1042&lt;/code&gt; running on AWS archtecture.&lt;/p&gt;
&lt;p&gt;The bootloader contains its own file system drivers (initramfs) that you can view if you know the &lt;code&gt;/boot/initrd*&lt;/code&gt; file that corresponds to the kernel image in use. The easiest way to do this is with the tools from &lt;code&gt;[initramfs-tools-core](https://packages.debian.org/initramfs-tools-core &amp;quot;DebianPackage&amp;quot;)&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## list files inside the initramfs  
$ lsinitramfs /boot/initrd.img-$(uname -r)  
.  
kernel  
kernel/x86  
.  
bin  
conf  
conf/arch.conf  
conf/conf.d  
conf/conf.d/resume  
-- snip --  
  
## extract files from the initramfs  
$ unmkinitramfs /boot/initrd.img-$(uname -r) initramfs/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This allows you to navigate the initramfs filesystem and gain a deeper understanding of how things are working as the system boots. If you extracted &lt;code&gt;initramfs&lt;/code&gt;, you’ll notice that upon looking in the directory &lt;code&gt;./initramfs&lt;/code&gt;, there are 3 folders: &lt;code&gt;early&lt;/code&gt;, &lt;code&gt;early2&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ls initramfs  
early early2 main
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the context of initramfs, &lt;code&gt;early&lt;/code&gt; and &lt;code&gt;early2&lt;/code&gt; refer to the first and second stage of the initial RAM filesystem. During the first stage, the minimal set of drivers and utilities that are needed to initialize the hardware and mount the real root filesystem are loaded. In the second stage, &lt;code&gt;early2&lt;/code&gt;, loads additional drivers and utilities needed to fully initialize the system.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;main&lt;/code&gt; folder of initramfs contains the actual root filesystem image, as well as any additional tools or drivers that may be needed during the boot process. Once the root filesystem has been mounted, the system can proceed to load the regular set of services and daemons needed to run the operating system.&lt;/p&gt;
&lt;h2 id=&#34;checking-signatures-manually&#34;&gt;Checking Signatures Manually&lt;/h2&gt;
&lt;p&gt;You can check which modules are digitally signed using the &lt;code&gt;modinfo&lt;/code&gt; command where a kernel’s signature will appear as a long string of hexadecimal values separated by colons.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ modinfo example.ko  
filename: /lib/modules/5.10.0-5-amd64/kernel/drivers/misc/example.ko  
version: 1.0.0  
license: GPL  
description: Example kernel module  
author: John Doe &amp;lt;jdoe@example.com&amp;gt;  
srcversion: 12AB34CD5678EF90ABCD1234  
sig\_key: A0:3B:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF  
sig\_hashalgo: sha256  
signature: 12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Thanks for reading this overview of Secure Boot. I would encourage you to do further reading in the sources linked below because this article only scratched the surface. I hope that from this article you were able to come to appreciate the beautifully complex system of a Linux machine turning on.&lt;/p&gt;
&lt;h1 id=&#34;sources&#34;&gt;Sources&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.ubuntu.com/UEFI/SecureBoot&#34;&gt;Ubuntu’s wiki&lt;/a&gt; on Secure Boot (detailed)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.ubuntu.com/Booting&#34;&gt;Ubuntu’s wiki on Booting Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html&#34;&gt;Linux Documentation- Kernel Module Signing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/WRFnOh_pqX8&#34;&gt;Mike Danslegio Explains Secure Boot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/User_space_and_kernel_space&#34;&gt;User Space and Kernel Space in Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/latest/filesystems/ramfs-rootfs-initramfs.html&#34;&gt;Kernel.org- Ramfs, rootfs, and initramfs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.debian.org/SecureBoot&#34;&gt;SecureBoot Debian Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itsfoss.com/check-uefi-or-bios/&#34;&gt;Check UEFI or BIOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/initrd.html&#34;&gt;Using the initial RAM disk (initrd)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ubuntupit.com/linux-boot-process-explained-step-by-step-for-beginners/&#34;&gt;Linux Boot Process Explained&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Preboot_Execution_Environment&#34;&gt;Preboot Execution Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://unix.stackexchange.com/questions/414799/efi-variable-entries-in-sys-firmware-efi-efivars&#34;&gt;EFI Variables- Stack Exchange&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://uefi.org/sites/default/files/resources/UEFI_Spec_2_9_2021_03_18.pdf&#34;&gt;UEFI Specification Version 2.9 (March 2021)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.debian.org/initramfs&#34;&gt;Initramfs Debian Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
  </channel>
</rss>
