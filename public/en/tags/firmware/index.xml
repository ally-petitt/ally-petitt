<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Firmware on Ally Petitt</title>
    <link>https://ally-petitt.com:443/en/tags/firmware/</link>
    <description>Recent content in Firmware on Ally Petitt</description>
    <generator>Hugo -- 0.123.7</generator>
    <language>en</language>
    <lastBuildDate>Fri, 05 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ally-petitt.com:443/en/tags/firmware/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to Use NVRAM When Emulating an Embedded Device</title>
      <link>https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/</link>
      <pubDate>Fri, 05 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, &lt;code&gt;httpd&lt;/code&gt;, that I was targeting. A smile spread across my face as I typed a command into the terminal to run &lt;code&gt;httpd&lt;/code&gt; in QEMU user mode, but after pressing the “Enter” key, I saw it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo chroot . ./qemu-armeb-static /usr/sbin/httpd -n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cannot open /dev/nvram
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Cannot open &lt;code&gt;/dev/nvram&lt;/code&gt;. This error highlights a somewhat common obstacle when emulating embedded devices. Interacting with NVRAM can be an important step in the expected execution of an application, which can be made even more complicated when emulating a device.&lt;/p&gt;
&lt;h3 id=&#34;the-solution&#34;&gt;The Solution&lt;/h3&gt;
&lt;p&gt;In this article, I’ll walk through one method that I used to hook into the functions that request and set data from &lt;code&gt;/dev/nvram&lt;/code&gt;, enabling me to intercept and modify interactions with the NVRAM while my target application runs. This allows us to have more granular control of the values returned by calls to the NVRAM so that we can return our desired values. As a result, the application runs smoothly as though an NVRAM device actually existed on the system. Think of it like a man-in-the-middle attack on NVRAM that our target application is oblivious to.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: By &amp;ldquo;target application&amp;rdquo; or &amp;ldquo;target binary&amp;rdquo;, I am referring to the binary that is being emulated in QEMU and relies on the NVRAM. In my specific case, this is &lt;code&gt;httpd&lt;/code&gt; in my extracted firmware.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This article aims to walk you through my thought process in approaching this rather than solely offering a copy-paste solution. I have found reading other researcher&amp;rsquo;s thought processes to be helpful in the past and was hoping to pay it forward. As such, my troubleshooting steps and some of my (failed) ideas are included.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLDR;&lt;/strong&gt; I built an instance of &lt;a href=&#34;https://github.com/crosstool-ng/crosstool-ng&#34;&gt;crosstool-ng&lt;/a&gt; to create a &lt;code&gt;armeb-unknown-eabi&lt;/code&gt; toolchain. This was necessary for me to cross-compile &lt;a href=&#34;https://github.com/zcutlip/nvram-faker&#34;&gt;nvram-faker&lt;/a&gt; in the target architecture: big endian, 32-bit ARM. Nvram-faker allowed us to hijack function calls originally intended for libnvram.so, which is a library used to interface with &lt;code&gt;/dev/nvram&lt;/code&gt;, through the &lt;code&gt;LD_PRELOAD&lt;/code&gt; variable. I ended up patching &lt;code&gt;nvram-faker&lt;/code&gt; in my &lt;a href=&#34;https://github.com/ally-petitt/nvram-faker&#34;&gt;own fork&lt;/a&gt; to solve dynamic linking issues and solve a bug that caused a segfault.&lt;/p&gt;
&lt;h3 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h3&gt;
&lt;p&gt;I am just a hobbyist. There are likely more efficient and/or robust ways to add support for NVRAM when emulating firmware with QEMU. This is just one of the solutions that I came across on my own. All the information in the article is accurate to the best of my knowledge and has the chance to be incorrect. I have done my best to fact-check the information presented.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://www.mouser.com/images/cypresssemiconductor/hd/tssop44.jpg&#34; alt=&#34;Picture of NVRAM&#34;  /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;what-is-nvram&#34;&gt;What is NVRAM?&lt;/h2&gt;
&lt;p&gt;NVRAM, or non-volatile RAM, is a type of computer memory that maintains the values stored within it after the computer has been turned off and on again. Often, the NVRAM contains configuration information that can help direct applications during the boot process or runtime. It is almost like a Solid-State Drive (SSD), but with far less storage capacity, increased speed, and it is generally soldered onto the motherboard.&lt;/p&gt;
&lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;
&lt;p&gt;The following table shows a high-level overview of the firmware I am dealing with.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Architecture&lt;/th&gt;
&lt;th&gt;ARMv5 (armeb)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Chipset&lt;/td&gt;
&lt;td&gt;IXP425&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ABI&lt;/td&gt;
&lt;td&gt;EABI5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Operating System&lt;/td&gt;
&lt;td&gt;OpenWRT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Endianess&lt;/td&gt;
&lt;td&gt;Big Endian&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt; Run the binary &lt;code&gt;/usr/sbin/httpd&lt;/code&gt; in our firmware image.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem:&lt;/strong&gt; &lt;code&gt;httpd&lt;/code&gt; relies on NVRAM for configuration data. Since we are emulating in QEMU, we do not have the physical NVRAM to provide this data, so &lt;code&gt;httpd&lt;/code&gt; is unable to initialize.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Potential Solutions:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a custom kernel module to respond with the expected values at &lt;code&gt;/dev/nvram&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;This can be more complex and would require reverse engineering of &lt;code&gt;libnvram.so&lt;/code&gt; to understand how &lt;code&gt;/dev/nvram&lt;/code&gt; expects to be interacted with in order to recreate the appropriate interface.&lt;/li&gt;
&lt;li&gt;Building a specific implementation for this firmware may be less portable to other firmware images compared to our 2nd possible solution.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hook function calls to libnvram.so and override their return value.
&lt;ul&gt;
&lt;li&gt;Potentially faster to implement.&lt;/li&gt;
&lt;li&gt;There is already an open-source project called &lt;a href=&#34;https://github.com/zcutlip/nvram-faker&#34;&gt;nvram-faker&lt;/a&gt; that can be used as a starting point.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Needless to say, I’ll be exploring solution 2 in this article. Although, I am open to creating the kernel module if it is requested since I can see if having educational value.&lt;/p&gt;
&lt;h2 id=&#34;nvram-faker&#34;&gt;Nvram faker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/zcutlip/nvram-faker&#34;&gt;Nvram-faker&lt;/a&gt; is a GitHub project created by Zachary Cutlip in 2013 to &amp;ldquo;intercept calls to libnvram when running embedded linux applications in emulated environments.&amp;rdquo; Despite its old age, &lt;code&gt;Nvram-faker&lt;/code&gt; is still very usable for today&amp;rsquo;s use cases.&lt;/p&gt;
&lt;h3 id=&#34;how-it-works&#34;&gt;How it Works&lt;/h3&gt;
&lt;p&gt;Our &lt;code&gt;httpd&lt;/code&gt; binary does not attempt to access &lt;code&gt;/dev/nvram&lt;/code&gt;, the NVRAM device file in the firmware, directly. Instead, it uses a shared object file called &lt;code&gt;libnvram.so&lt;/code&gt; in order to abstract interaction with NVRAM. This dependency on &lt;code&gt;libnvram.so&lt;/code&gt; is evident in the &amp;ldquo;About&amp;rdquo; window on &lt;code&gt;httpd&lt;/code&gt; in Ghidra.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-1.png&#34; alt=&#34;Picture of linked libraries on the httpd binary&#34;  /&gt;

&lt;em&gt;Yes, my Ghidra is in dark mode.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;httpd&lt;/code&gt; program imports functions like &lt;code&gt;nvram_get()&lt;/code&gt; and &lt;code&gt;nvram_set()&lt;/code&gt; from &lt;code&gt;libnvram.so&lt;/code&gt; that manage interactions with &lt;code&gt;/dev/nvram&lt;/code&gt;. If we were able to set our own definitions for what &lt;code&gt;nvam_get()&lt;/code&gt; and &lt;code&gt;nvram_set()&lt;/code&gt; do, we can effectively control the values that &lt;code&gt;httpd&lt;/code&gt; recieves when attempting to interact with the NVRAM through these functions.&lt;/p&gt;
&lt;p&gt;That is what &lt;code&gt;nvram-faker&lt;/code&gt; does. We can recreate the NVRAM-related procedures called by &lt;code&gt;httpd&lt;/code&gt; in &lt;code&gt;nvram-faker.c&lt;/code&gt; and compile them into our own library, &lt;code&gt;libnvram-faker.so&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Furthermore, &lt;code&gt;httpd&lt;/code&gt; dynamically links the &lt;code&gt;libnvram.so&lt;/code&gt; library with the dynamic linker &lt;a href=&#34;https://man7.org/linux/man-pages/man8/ld.so.8.html&#34;&gt;ld&lt;/a&gt;. By setting the environment variable &lt;code&gt;LD_PRELOAD&lt;/code&gt; to &lt;code&gt;libnvram-faker.so&lt;/code&gt;, &lt;code&gt;ld&lt;/code&gt; is instructed to load our crafted shared object file before the real &lt;code&gt;libnvram.so&lt;/code&gt; library is loaded in. Consequently, the NVRAM-related procedures that we defined in &lt;code&gt;nvram-faker.c&lt;/code&gt; (and by extension &lt;code&gt;libnvram-faker.so&lt;/code&gt;) will be called instead of the intended symbols in &lt;code&gt;libnvram.so&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nvram-faker&lt;/code&gt; is programmed to parse through key-value pairs stored in a &lt;code&gt;/nvram.ini&lt;/code&gt; file in the firmware squashfs root. When the target binary calls &lt;code&gt;nvram_get()&lt;/code&gt;, the value defined in &lt;code&gt;/nvram.ini&lt;/code&gt; for the requested key is returned.&lt;/p&gt;
&lt;h1 id=&#34;building-nvram-faker&#34;&gt;Building Nvram-Faker&lt;/h1&gt;
&lt;p&gt;As previously mentioned, the firmware that I am emulating is big-endian, 32-bit ARM. Since &lt;code&gt;libnvram-faker.so&lt;/code&gt; will be preloaded into a binary in that firmware, it must match that ARM architecture. This means that I will need to cross-compile our &lt;code&gt;nvram-faker&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Cross-compiling requires a cross-compilation toolchain. ARM offsers plenty of &lt;a href=&#34;https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain&#34;&gt;toolchains&lt;/a&gt;, however, none of them matched what I was looking for, so I decided to use &lt;a href=&#34;https://github.com/crosstool-ng/crosstool-ng&#34;&gt;crosstool-ng&lt;/a&gt; to compile my own toolchain. You can read their &lt;a href=&#34;https://crosstool-ng.github.io/docs/&#34;&gt;documentation&lt;/a&gt; for more information on how this works.&lt;/p&gt;
&lt;h2 id=&#34;making-a-cross-compilation-toolchain-with-crosstool-ng&#34;&gt;Making a Cross-Compilation Toolchain with Crosstool-ng&lt;/h2&gt;
&lt;p&gt;I used the following commands to begin building &lt;code&gt;crosstool-ng&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install help2man libtool-bin &lt;span style=&#34;color:#75715e&#34;&gt;#dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/crosstool-ng/crosstool-ng
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd crosstool-ng
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout tags/crosstool-ng-1.26.0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./bootstrap
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./configure --prefix&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$PWD&lt;span style=&#34;color:#e6db74&#34;&gt;/build&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With the created &lt;code&gt;ct-ng&lt;/code&gt; binary, I began to configure my toolchain. Luckily, there was already a sample configuration from &lt;code&gt;armeb-unknown-eabi&lt;/code&gt;, which is a match for my target architecture (I was able to tell based on the &lt;a href=&#34;https://stackoverflow.com/questions/5731495/can-anyone-explain-the-gcc-cross-compiler-naming-convention/5731708#5731708&#34;&gt;toolchain naming conventions&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./build/bin/ct-ng show-samples
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./build/bin/ct-ng show-armeb-unknown-eabi
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./build/bin/ct-ng armeb-unknown-eabi &lt;span style=&#34;color:#75715e&#34;&gt;# load it into config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./build/bin/ct-ng menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I verified in the menu configuration that the settings for our target toolchain matched what I was expecting for this compilation in the “Target Options” menu.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-2.png&#34; alt=&#34;Picture of the &amp;amp;ldquo;Target Options&amp;amp;rdquo; menu in the ct-ng menuconfig&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;I later encountered difficulties with downloading the tarballs needed by &lt;code&gt;crosstool-ng&lt;/code&gt;. To resolve this, I configured a mirror: &lt;a href=&#34;https://ftp.gnu.org/gnu/&#34;&gt;https://ftp.gnu.org/gnu/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-5.png&#34; alt=&#34;Mirror added to menuconfig&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;Future me experienced more errors relating to missing necessary C library header files. To address this, I enabled newlib.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-6.png&#34; alt=&#34;Enabling the newlib C library in the ct-ng menuconfig&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;We can now begin to build our target toolchain!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./build/bin/ct-ng build
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The build process took about 40 minutes and eventually resulted in an error when attempting to compile &lt;code&gt;gdbserver&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;ERROR&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;    configure: error: C compiler cannot create executables
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;CFG  &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;    See &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;config.log&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; more details
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I was worried that this error may have stopped the target toolchain from being created. I searched within the &lt;code&gt;.build&lt;/code&gt; directory of &lt;code&gt;crosstool-ng&lt;/code&gt; to check that the target binaries I was looking for were created.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ find . -name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*armeb-unknown-eabi*&amp;#39;&lt;/span&gt; -type f
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcc.1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-tool.1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov.1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-cpp.1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-dump.1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-tool
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ranlib
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-cpp
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ar
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-nm
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-dump
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-13.2.0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Perfect, the tools we need have been built. We can use the gdbserver built into QEMU for debugging.  Let’s begin to compile nvram-faker.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/zcutlip/nvram-faker.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd nvram-faker
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CC&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Unfortunately, attempting to build nvram-faker with &lt;code&gt;make&lt;/code&gt; resulted in two distinct errors. First, the file &lt;code&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o&lt;/code&gt; was not found.&lt;/p&gt;
&lt;p&gt;Let’s investigate.&lt;/p&gt;
&lt;h2 id=&#34;troubleshooting-nvram-faker-compilation&#34;&gt;Troubleshooting Nvram-Faker Compilation&lt;/h2&gt;
&lt;p&gt;Since &lt;code&gt;make&lt;/code&gt; appeared to expect &lt;code&gt;crt0.o&lt;/code&gt; in a specific location, I figured that changing the search path to include the location that it was actually at would resolve the issue. I began by locating a copy of &lt;code&gt;crt0.o&lt;/code&gt; that exists&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ find . -name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;crt0.o&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then, I used &lt;code&gt;$CFLAGS&lt;/code&gt; such as &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; to include the path &lt;code&gt;./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/&lt;/code&gt;. I also tried including the &lt;code&gt;crt0.o&lt;/code&gt; file directly by manually using the &lt;code&gt;armeb-unkown-eabi-gcc&lt;/code&gt; compiler with &lt;code&gt;crt0.o&lt;/code&gt; as an input file, but neither of these worked.&lt;/p&gt;
&lt;p&gt;I ultimately decided to copy &lt;code&gt;crt0.o&lt;/code&gt; to the location that the cross-compiler was searching for it at.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir -p $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# the symlink didn&amp;#39;t work&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#ln -s ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/crt0.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now that we&amp;rsquo;ve solved the first error, let&amp;rsquo;s move on to the next!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kali@kali:~/Documents/firmware/nvram-faker$ CC&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -ggdb -DINI_MAX_LINE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2000&lt;/span&gt; -DINI_USE_STACK&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; -fPIC -c -o nvram-faker.o nvram-faker.c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nvram-faker.c:1:10: fatal error: stdlib.h: No such file or directory
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; | &lt;span style=&#34;color:#75715e&#34;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      |          ^~~~~~~~~~
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;compilation terminated.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make: *** &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Makefile:35: nvram-faker.o&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; Error &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It seems that &lt;code&gt;make&lt;/code&gt; was having difficulty with finding our C library. I ended up searching for the &lt;code&gt;stdlib.h&lt;/code&gt; header file in the &lt;code&gt;crosstool-ng&lt;/code&gt; directory.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~/Documents/firmware/crosstool-ng$ find . -name stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/gcc-13.2.0/fixincludes/tests/base/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/gcc-13.2.0/fixincludes/tests/base/ansi/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/gcc-13.2.0/libstdc++-v3/include/tr1/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/gcc-13.2.0/libstdc++-v3/include/c_compatibility/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/newlib-4.3.0.20230120/newlib/libc/include/ssp/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/newlib-4.3.0.20230120/newlib/libc/include/machine/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/newlib-4.3.0.20230120/newlib/libc/include/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./.build/src/newlib-4.3.0.20230120/newlib/libc/machine/powerpc/machine/stdlib.h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I first tried using the stdlib from &lt;code&gt;./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/&lt;/code&gt;, however, this resulted additional errors. My speculation is that the header files in there were intended for my host architecture, x64, and not the target architecture of 32-bit, big-endian ARM.&lt;/p&gt;
&lt;p&gt;This was the point that I realized that rebuilding with newlib would solve this problem. This enabled me to include &lt;code&gt;./.build/src/newlib-4.3.0.20230120/newlib/libc/include/&lt;/code&gt; as a search directory in our make command via the CFLAGS &lt;code&gt;-I&lt;/code&gt; option:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; make CC&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-I&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With that, our problems are solved.&lt;/p&gt;
&lt;h3 id=&#34;compiling-nvram-faker&#34;&gt;Compiling nvram-faker.&lt;/h3&gt;
&lt;p&gt;Now that we are properly set up for building &lt;code&gt;nvram-faker&lt;/code&gt;, let’s run &lt;code&gt;make&lt;/code&gt; to create &lt;code&gt;libnvram-faker.so&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make CC&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-I&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make: Nothing to be &lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;all&amp;#39;&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file ./libnvram-faker.so 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./libnvram-faker.so: ELF 32-bit MSB shared object, ARM, EABI5 version &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;SYSV&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;, dynamically linked, with debug_info, not stripped
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;file&lt;/code&gt; output is exactly what we want as it matches the other binaries executed on the firmware like busybox:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ file ./bin/busybox 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./bin/busybox: ELF 32-bit MSB executable, ARM, EABI5 version &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;SYSV&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;, dynamically linked, interpreter /lib/ld-musl-armeb.so.1, no section header
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;using-nvram-faker&#34;&gt;Using nvram-faker&lt;/h3&gt;
&lt;p&gt;Now, I’ll copy the libnvram-faker.so file and re-enter the chroot environment at the base of our firmware image’s squashfs file system.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp ../../nvram-faker/libnvram-faker.so .
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;touch nvram.ini
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s test it!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo chroot . ./qemu-armeb-static /bin/sh -c &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: __libc_init_array: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: main: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: __heap_limit: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: _impure_ptr: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: _ctype_: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hm, it looks like we have some more errors to resolve. Let’s understand why these are happening and address them. Based on the error message, I am going to assume that the linker was expecting the symbols above to be in our library (perhaps as some ABI standard?) and since they were not found, it has difficulty with determining where to place our library in memory. This is just a guess, so feel free to correct me if I’m wrong.&lt;/p&gt;
&lt;h3 id=&#34;troubleshooting-libnvram-fakerso&#34;&gt;Troubleshooting libnvram-faker.so&lt;/h3&gt;
&lt;p&gt;I had two ideas that I thought may resolve this by including the expected symbols:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Recompiling &lt;code&gt;libnvram-faker.so&lt;/code&gt; with our cross-compiled  &lt;code&gt;ld&lt;/code&gt;, &lt;code&gt;ar&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;strip&lt;/code&gt;, and &lt;code&gt;nm&lt;/code&gt; binaries since I did not include these before.
&lt;ul&gt;
&lt;li&gt;This operates on the assumption that including these binaries would automatically create the expected symbols.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Manually patching &lt;code&gt;nvram-faker.c&lt;/code&gt; to include the symbols that the linker is expecting.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I started out testing the first idea.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make clean
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm *.o
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm *.so
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm nvram_faker_exe
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm: cannot remove &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;nvram_faker_exe&amp;#39;&lt;/span&gt;: No such file or directory
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make: &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;Makefile:46: clean&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; Error &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ignored&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make -C ./contrib/inih clean
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;: Entering directory &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm *.o
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;: Leaving directory &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make CC&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-I&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include&amp;#34;&lt;/span&gt; LD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ld AR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ar STRIP&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-strip NM&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-nm 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o nvram-faker.o nvram-faker.c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make -C ./contrib/inih ini.o
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;: Entering directory &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o ini.o ini.c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;: Leaving directory &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp ./contrib/inih/ini.o .
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -shared -o libnvram-faker.so nvram-faker.o ini.o -Wl,-nostdlib
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After copying it back to our squashfs root and trying again, it seems the same issue persists. This rules out incompatible &lt;code&gt;ld&lt;/code&gt;, &lt;code&gt;ar&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;strip&lt;/code&gt;, or &lt;code&gt;nm&lt;/code&gt; binaries as the root cause. I wasn&amp;rsquo;t confident that this would be the solution, but it was worth a shot. Now I know more.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cp ./libnvram-faker.so ../_extracted_firmware/squashfs-root/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo chroot . ./qemu-armeb-static /bin/sh -c &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: __libc_init_array: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: main: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: __heap_limit: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: _impure_ptr: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Error relocating /libnvram-faker.so: _ctype_: symbol not found
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Instead, let’s attempt the second idea. I created &lt;a href=&#34;https://github.com/ally-petitt/nvram-faker&#34;&gt;my own fork&lt;/a&gt; of nvram-faker and got to work.&lt;/p&gt;
&lt;p&gt;As I was creating the patch to manually add the expected symbols into &lt;code&gt;nvram-faker.c&lt;/code&gt;, I made the observation that many of these symbols were defined in common C libraries like &lt;code&gt;ctypes.h&lt;/code&gt; and &lt;code&gt;stdlib.h&lt;/code&gt;. This made me suspect that the issue might reside in the flags relating to the C library.&lt;/p&gt;
&lt;p&gt;I quickly tried recompiling without the &lt;code&gt;-nostdlib&lt;/code&gt; flag by modifying the &lt;code&gt;nvram-faker&lt;/code&gt; &lt;code&gt;Makefile&lt;/code&gt; and recompiling with the &lt;code&gt;-static&lt;/code&gt; flag. Neither of these worked, so I continued with the original plan, which involved appending the following to &lt;code&gt;nvram-faker.c&lt;/code&gt; and recompiling:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;void main&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	write&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;1, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;libnvram-faker.so has loaded\n&amp;#34;&lt;/span&gt;, 29&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;void* initialise_monitor_handles;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;void* __heap_limit;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;void &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;*__libc_fini_array&lt;span style=&#34;color:#f92672&#34;&gt;[])&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;void&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;void &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;*__libc_init_array&lt;span style=&#34;color:#f92672&#34;&gt;[])&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;void&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;struct _reent * _impure_ptr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;char _ctype_;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I discovered the data types that work through a combination of compiler warnings and grepping for definitions such as:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kali@kali:~/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include$ grep -r &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;_ctype_&amp;#34;&lt;/span&gt; .
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./ctype.h:extern	__IMPORT const char	_ctype_&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let’s try to run this again!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ sudo chroot . ./qemu-armeb-static /bin/sh -c &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cannot open /dev/nvram
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;httpd : httpd cannot start. ssl and/or http must be selected
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Well, our library loaded successfully this time, but it’s not quite what we were hoping for. From my prior reverse engineering of interesting libraries in this firmware, I knew that the error message we received comes from &lt;code&gt;libnvram.so&lt;/code&gt;, which we can verify with grep.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ grep -r &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cannot open /dev/nvram&amp;#34;&lt;/span&gt; .
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Binary file ./lib/libnvram.so matches
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;debugging-libnvram-fakerso&#34;&gt;Debugging Libnvram-faker.so&lt;/h3&gt;
&lt;p&gt;I wanted to get to the root of why this error message was still appearing despite using &lt;code&gt;libnvram-faker.so&lt;/code&gt; to hook NVRAM-related functionality.&lt;/p&gt;
&lt;h4 id=&#34;attempt-1-gdb&#34;&gt;Attempt 1: GDB&lt;/h4&gt;
&lt;p&gt;I first attempted to debug using GDB. In QEMU, I used the built-in GDB server to listen on port 1234.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo chroot . ./qemu-armeb-static -g &lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt; -E LD_PRELOAD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/libnvram-faker.so /usr/sbin/httpd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;in another terminal window I modified my &lt;code&gt;.gdbinit&lt;/code&gt; file to expidite up the process of connecting and debugging to our target application.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat ~/.gdbinit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set disassembly-flavor intel
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set print asm-demangle on
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source $HOME/Downloads/pwndbg/gdbinit.py
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set arch arm
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set follow-fork-mode child
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;target extended-remote :1234
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then, I connected to the remote process.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;gdb-multiarch ./usr/sbin/httpd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-7.png&#34; alt=&#34;Pwndbg context output after connecting to the httpd debugging process&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;To make debugging easier, I calculated the offset of the memory addresses in our debugging process to memory addresses in the &lt;code&gt;httpd&lt;/code&gt; binary itself. When I ran the &lt;code&gt;load&lt;/code&gt; command in GDB with this offset as the second parameter, it made the addresses in the debugger consistent with those in my Ghidra CodeBrowser.&lt;/p&gt;
&lt;p&gt;To make this calculation, I subtracted PC (the ARM &lt;a href=&#34;https://developer.arm.com/documentation/107656/0101/Registers/Registers-in-the-register-bank/R15--Program-Counter--PC-&#34;&gt;program counter register&lt;/a&gt;) with the address of the first entry instruction in &lt;code&gt;httpd&lt;/code&gt; to adjust our addresses to match that of the binary.&lt;/p&gt;
&lt;blockquote&gt;


&lt;p&gt;&lt;details &gt;
  &lt;summary markdown=&#34;span&#34;&gt;&lt;strong&gt;Note on verifying offset&lt;/strong&gt;&lt;/summary&gt;
  I had verified that we were at the first entry instruction by matching the byte sequence that our PC was at (&lt;code&gt;x/3wx $PC&lt;/code&gt;) to the hex dump of the &lt;code&gt;httpd&lt;/code&gt; entrypoint (made easier through the use of a Ghidra search functionality).
&lt;/details&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pwndbg&amp;gt; load ./usr/sbin/httpd &lt;span style=&#34;color:#ae81ff&#34;&gt;4286266732&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is where the problems with GDB began. There appeared to be an issue with the timing of the program between when I connected to the debugging process and it began execution. If the delay was more than a few milliseconds, the &lt;code&gt;libc_start_main&lt;/code&gt; function would have a segmentation fault. I tried automating loading the program and setting breakpoints in &lt;code&gt;.gdbinit&lt;/code&gt;, but even this was not fast enough to prevent a segfault.&lt;/p&gt;
&lt;p&gt;I don’t know if there was a race condition or something else preventing normal execution. If anyone knows why this may have happened, please do let me know since I am quite puzzled by it.&lt;/p&gt;
&lt;p&gt;I asked myself the question, “is there another way to do this?”. I realized what I was really looking for was a call stack for when that error message was printed. I got an idea of how I could recreate this through static analysis.&lt;/p&gt;
&lt;h4 id=&#34;attempt-2-ghidra&#34;&gt;Attempt 2: Ghidra&lt;/h4&gt;
&lt;p&gt;I started by pinpointing where our error message appears and checking its implementation in our fake NVRAM library.&lt;/p&gt;
&lt;p&gt;In Ghidra, I opened a project with &lt;code&gt;libnvram.so&lt;/code&gt; loaded in the CodeBrowser. Using the built-in tool &lt;code&gt;Window &amp;gt; Defined Strings&lt;/code&gt;, I was able to search for our error message, “&lt;code&gt;cannot open /dev/nvram&lt;/code&gt;.&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-8.png&#34; alt=&#34;Ghidra defined strings window showing our error message&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;I followed the location of this string in the binary to reveal that it is referenced in a procedure that Ghidra called &lt;code&gt;FUN_00012420&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-9.png&#34; alt=&#34;The error message in the disassembly of the binary&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;This function is called by some of the major functions in &lt;code&gt;libnvram.so&lt;/code&gt; such as &lt;code&gt;nvram_get&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-10.png&#34; alt=&#34;The call tree of FUN_00012420&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;When quickly listing the NVRAM functions imported in &lt;code&gt;httpd&lt;/code&gt;(which there are defined strings for), it does not appear that &lt;code&gt;httpd&lt;/code&gt; is calling a libnvram function that would trigger our error. However, that doesn’t mean that a call to this endpoint isn’t abstracted some other way.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-11.png&#34; alt=&#34;Defined strings with &amp;amp;ldquo;nvram&amp;amp;rdquo; in them in &amp;lt;code&amp;gt;httpd&amp;lt;/code&amp;gt;&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;I decided to analyze a complete call graph of &lt;code&gt;FUN_00012420&lt;/code&gt; (as opposed to the first layer of the call tree), which confirmed my suspicions: &lt;code&gt;nvram_set&lt;/code&gt; called a function that called &lt;code&gt;FUN_00012420&lt;/code&gt;. This means that &lt;code&gt;nvram_set&lt;/code&gt;, a function called by &lt;code&gt;httpd&lt;/code&gt;, was very likely the entrypoint to our “&lt;code&gt;cannot find /dev/nvram&lt;/code&gt;” error message.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ally-petitt.com:443/images/nvram-12.png&#34; alt=&#34;Call graph of FUN_00012420&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;As stated in the &lt;code&gt;nvram-faker&lt;/code&gt; &lt;a href=&#34;https://github.com/zcutlip/nvram-faker?tab=readme-ov-file#using&#34;&gt;README&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The library currently does not support calls to &lt;code&gt;nvram_set()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;My hypothesis was that since &lt;code&gt;nvram_set()&lt;/code&gt; was not defined in the &lt;code&gt;libnvram-faker.so&lt;/code&gt; library that we created, it was being imported from &lt;code&gt;libnvram.so&lt;/code&gt;. In turn, &lt;code&gt;FUN_00012420&lt;/code&gt; is called which attempts to open &lt;code&gt;/dev/nvram&lt;/code&gt; and fails (since the kernel module for &lt;code&gt;/dev/nvram&lt;/code&gt; does not exist), printing our error message.&lt;/p&gt;
&lt;p&gt;To verify that this is the case, I once again patched &lt;code&gt;nvram-faker.c&lt;/code&gt;, but this time I implemented a preliminary definition for &lt;code&gt;nvram_set&lt;/code&gt; and observe whether the error from before is still present.&lt;/p&gt;
&lt;p&gt;The following is what I added to &lt;code&gt;nvram-faker.c&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;char * nvram_set&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;char * key, char * value&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	write&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;1, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;nvram_set called\n&amp;#34;&lt;/span&gt;, 17&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After I compiled and ran &lt;code&gt;httpd&lt;/code&gt;, this was my output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo chroot . ./qemu-armeb-static -E LD_PRELOAD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/libnvram-faker.so /usr/sbin/httpd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nvram_set called
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;httpd : httpd cannot start. ssl and/or http must be selected
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Perfect! The previous error that &lt;code&gt;/dev/nvram&lt;/code&gt; was not found is no longer appearing and in its place is the output that we injected for the &lt;code&gt;nvram_set()&lt;/code&gt; function I defined. This verifies that &lt;code&gt;nvram_set&lt;/code&gt; was the source of the error messages. Now, we can create our own implementation of &lt;code&gt;nvram_set&lt;/code&gt; to enable full functionality of &lt;code&gt;httpd.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To streamline the development process, I made my own script to clean, build, and test the library:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -e &lt;span style=&#34;color:#75715e&#34;&gt;# exit on failure&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; $# -ne &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Usage: &lt;/span&gt;$0&lt;span style=&#34;color:#e6db74&#34;&gt; &amp;lt;compilation_toolchain_binaries_path&amp;gt; &amp;lt;squashfs_root_path&amp;gt; &amp;lt;newlib_path&amp;gt; &amp;lt;target_binary_path&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Example: &lt;/span&gt;$0&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/x-tools/armeb-unknown-eabi/bin &lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/_extracted_firmware/squashfs-root &lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include /usr/sbin/httpd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  exit &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TOOLCHAIN_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SQUASHFS_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NEWLIB_PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TARGET_BINARY&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make clean
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make CC&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;TOOLCHAIN_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/armeb-unknown-eabi-gcc&amp;#34;&lt;/span&gt; CFLAGS&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-DDEBUG=1 -I&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;NEWLIB_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; LD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;TOOLCHAIN_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/armeb-unknown-eabi-ld AR=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;TOOLCHAIN_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/armeb-unknown-eabi-ar STRIP=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;TOOLCHAIN_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/armeb-unknown-eabi-strip NM=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;TOOLCHAIN_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/armeb-unknown-eabi-nm&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cp ./libnvram-faker.so &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;SQUASHFS_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo chroot &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;SQUASHFS_PATH&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; ./qemu-armeb-static -E LD_PRELOAD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/libnvram-faker.so &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;TARGET_BINARY&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I encountered a segmentation fault when debug was enabled due to how &lt;code&gt;fprintf&lt;/code&gt; was being used to log debug output through the &lt;code&gt;DEBUG_PRINTF&lt;/code&gt; macro. I ended up redefining &lt;code&gt;DEBUG_PRINTF&lt;/code&gt; and &lt;code&gt;LOG_PRINTF&lt;/code&gt; to be based on &lt;code&gt;printf&lt;/code&gt; instead of &lt;code&gt;fprintf&lt;/code&gt; to prevent the segfault.&lt;/p&gt;
&lt;blockquote&gt;


&lt;p&gt;&lt;details &gt;
  &lt;summary markdown=&#34;span&#34;&gt;&lt;strong&gt;Expand to learn why fprintf was originally used instead of printf&lt;/strong&gt;&lt;/summary&gt;
  After a bit of digging, I would discover that &lt;code&gt;fprintf()&lt;/code&gt; was used for debug and log output in the original &lt;code&gt;nvram-faker&lt;/code&gt; repository as a workaround to how &lt;code&gt;stdout&lt;/code&gt; was being redirected after &lt;code&gt;system()&lt;/code&gt; was called in the webserver it was used to emulate. As explained in the &lt;a href=&#34;https://shadowfile.inode.link/blog/2015/01/patching-emulating-and-debugging-a-netgear-embedded-web-server/&#34;&gt;author’s blogpost&lt;/a&gt;, &lt;code&gt;fprintf()&lt;/code&gt; allowed him to print to &lt;code&gt;stderr&lt;/code&gt;, which was visible in the console, unlike the output of &lt;code&gt;printf()&lt;/code&gt; that goes to &lt;code&gt;stdout&lt;/code&gt; and was not visible after &lt;code&gt;system()&lt;/code&gt; was called.
&lt;/details&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h3 id=&#34;adding-support-for-nvram_set&#34;&gt;Adding Support for nvram_set&lt;/h3&gt;
&lt;p&gt;It was originally my intention to add &lt;code&gt;nvram_set()&lt;/code&gt; support to &lt;code&gt;nvram-faker.c&lt;/code&gt; in order to fully mimic a real NVRAM interaction, however, an event came up in my personal life that delayed this. I may endeavor to do so in the future when the timing is better, however, for now I have opted to simply create my &lt;a href=&#34;https://github.com/ally-petitt/nvram-faker&#34;&gt;own fork&lt;/a&gt; with the following improvements on the old one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;More informative debug output&lt;/li&gt;
&lt;li&gt;Resolve segmentation fault in debugging output&lt;/li&gt;
&lt;li&gt;Added additional symbols to &lt;code&gt;nvram-faker.c&lt;/code&gt; such as &lt;code&gt;initialise_monitor_handles&lt;/code&gt; and &lt;code&gt;__libc_fini_array&lt;/code&gt; to avoid linking errors&lt;/li&gt;
&lt;li&gt;Add a preliminary &lt;code&gt;nvram_set()&lt;/code&gt; function that logs debug output to prevent function calls to &lt;code&gt;libnvram.so&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add a &lt;code&gt;build_and_run.sh&lt;/code&gt; script to streamline development and testing&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;From here, you can simply create and populate an &lt;code&gt;nvram.ini&lt;/code&gt; file at the root of your extracted firmware filesystem and add the keys-value pairs that your target application expects! There are many ways to figure out these expected values. For instance, you can run the target application and view the NVRAM values it requests in the debugging output. You can also reverse engineer the target application to see the values it expects.&lt;/p&gt;
&lt;p&gt;Here is an excerpt from the &lt;code&gt;nvram-faker&lt;/code&gt; example &lt;a href=&#34;https://github.com/zcutlip/nvram-faker/blob/master/nvram.ini&#34;&gt;nvram.ini&lt;/a&gt; file for reference:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[config]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;os_name=linux
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;os_version=1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;upnp_port=9999
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;upnp_ad_time=30
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;upnp_sub_timeout=60
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;upnp_conn_retries=10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;log_level=10
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lan_hwaddr=52:54:00:12:34:58
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lan_ifname=eth0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lan1_ifname=wlan0
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This article was quite lengthy and technical compared to what I normally put out. It really started as me wanting to test out a chroot sandbox on a router and escalated into emulating a webserver and needing a way to interface with NVRAM. This was a great exercise that taught me more about cross-compilation, NVRAM, and general troubleshooting. Past me would have been overwhelmed by the amount of errors that I had to work through to get this to work (this article didn&amp;rsquo;t even detail half of them for brevity), so working through this helped to strengthen my perserverance as a researcher.&lt;/p&gt;
&lt;p&gt;Overall, this was an interesting rabbit hole to go down. I hope it made as much sense in text as it did in my head. If any details in here were inaccurate, please feel free to contact me and I will be happy to correct the information in this article.&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;
</description>
      <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, <code>httpd</code>, that I was targeting. A smile spread across my face as I typed a command into the terminal to run <code>httpd</code> in QEMU user mode, but after pressing the “Enter” key, I saw it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo chroot . ./qemu-armeb-static /usr/sbin/httpd -n
</span></span><span style="display:flex;"><span>cannot open /dev/nvram
</span></span></code></pre></div><p>Cannot open <code>/dev/nvram</code>. This error highlights a somewhat common obstacle when emulating embedded devices. Interacting with NVRAM can be an important step in the expected execution of an application, which can be made even more complicated when emulating a device.</p>
<h3 id="the-solution">The Solution</h3>
<p>In this article, I’ll walk through one method that I used to hook into the functions that request and set data from <code>/dev/nvram</code>, enabling me to intercept and modify interactions with the NVRAM while my target application runs. This allows us to have more granular control of the values returned by calls to the NVRAM so that we can return our desired values. As a result, the application runs smoothly as though an NVRAM device actually existed on the system. Think of it like a man-in-the-middle attack on NVRAM that our target application is oblivious to.</p>
<p><em>Note: By &ldquo;target application&rdquo; or &ldquo;target binary&rdquo;, I am referring to the binary that is being emulated in QEMU and relies on the NVRAM. In my specific case, this is <code>httpd</code> in my extracted firmware.</em></p>
<p>This article aims to walk you through my thought process in approaching this rather than solely offering a copy-paste solution. I have found reading other researcher&rsquo;s thought processes to be helpful in the past and was hoping to pay it forward. As such, my troubleshooting steps and some of my (failed) ideas are included.</p>
<p><strong>TLDR;</strong> I built an instance of <a href="https://github.com/crosstool-ng/crosstool-ng">crosstool-ng</a> to create a <code>armeb-unknown-eabi</code> toolchain. This was necessary for me to cross-compile <a href="https://github.com/zcutlip/nvram-faker">nvram-faker</a> in the target architecture: big endian, 32-bit ARM. Nvram-faker allowed us to hijack function calls originally intended for libnvram.so, which is a library used to interface with <code>/dev/nvram</code>, through the <code>LD_PRELOAD</code> variable. I ended up patching <code>nvram-faker</code> in my <a href="https://github.com/ally-petitt/nvram-faker">own fork</a> to solve dynamic linking issues and solve a bug that caused a segfault.</p>
<h3 id="disclaimer">Disclaimer</h3>
<p>I am just a hobbyist. There are likely more efficient and/or robust ways to add support for NVRAM when emulating firmware with QEMU. This is just one of the solutions that I came across on my own. All the information in the article is accurate to the best of my knowledge and has the chance to be incorrect. I have done my best to fact-check the information presented.</p>
<p><img loading="lazy" src="https://www.mouser.com/images/cypresssemiconductor/hd/tssop44.jpg" alt="Picture of NVRAM"  />
</p>
<h2 id="what-is-nvram">What is NVRAM?</h2>
<p>NVRAM, or non-volatile RAM, is a type of computer memory that maintains the values stored within it after the computer has been turned off and on again. Often, the NVRAM contains configuration information that can help direct applications during the boot process or runtime. It is almost like a Solid-State Drive (SSD), but with far less storage capacity, increased speed, and it is generally soldered onto the motherboard.</p>
<h2 id="setup">Setup</h2>
<p>The following table shows a high-level overview of the firmware I am dealing with.</p>
<table>
<thead>
<tr>
<th>Architecture</th>
<th>ARMv5 (armeb)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chipset</td>
<td>IXP425</td>
</tr>
<tr>
<td>ABI</td>
<td>EABI5</td>
</tr>
<tr>
<td>Operating System</td>
<td>OpenWRT</td>
</tr>
<tr>
<td>Endianess</td>
<td>Big Endian</td>
</tr>
</tbody>
</table>
<p><strong>Goal:</strong> Run the binary <code>/usr/sbin/httpd</code> in our firmware image.</p>
<p><strong>Problem:</strong> <code>httpd</code> relies on NVRAM for configuration data. Since we are emulating in QEMU, we do not have the physical NVRAM to provide this data, so <code>httpd</code> is unable to initialize.</p>
<p><strong>Potential Solutions:</strong></p>
<ol>
<li>Create a custom kernel module to respond with the expected values at <code>/dev/nvram</code>.
<ul>
<li>This can be more complex and would require reverse engineering of <code>libnvram.so</code> to understand how <code>/dev/nvram</code> expects to be interacted with in order to recreate the appropriate interface.</li>
<li>Building a specific implementation for this firmware may be less portable to other firmware images compared to our 2nd possible solution.</li>
</ul>
</li>
<li>Hook function calls to libnvram.so and override their return value.
<ul>
<li>Potentially faster to implement.</li>
<li>There is already an open-source project called <a href="https://github.com/zcutlip/nvram-faker">nvram-faker</a> that can be used as a starting point.</li>
</ul>
</li>
</ol>
<p>Needless to say, I’ll be exploring solution 2 in this article. Although, I am open to creating the kernel module if it is requested since I can see if having educational value.</p>
<h2 id="nvram-faker">Nvram faker</h2>
<p><a href="https://github.com/zcutlip/nvram-faker">Nvram-faker</a> is a GitHub project created by Zachary Cutlip in 2013 to &ldquo;intercept calls to libnvram when running embedded linux applications in emulated environments.&rdquo; Despite its old age, <code>Nvram-faker</code> is still very usable for today&rsquo;s use cases.</p>
<h3 id="how-it-works">How it Works</h3>
<p>Our <code>httpd</code> binary does not attempt to access <code>/dev/nvram</code>, the NVRAM device file in the firmware, directly. Instead, it uses a shared object file called <code>libnvram.so</code> in order to abstract interaction with NVRAM. This dependency on <code>libnvram.so</code> is evident in the &ldquo;About&rdquo; window on <code>httpd</code> in Ghidra.</p>
<p><img loading="lazy" src="/images/nvram-1.png" alt="Picture of linked libraries on the httpd binary"  />

<em>Yes, my Ghidra is in dark mode.</em></p>
<p>The <code>httpd</code> program imports functions like <code>nvram_get()</code> and <code>nvram_set()</code> from <code>libnvram.so</code> that manage interactions with <code>/dev/nvram</code>. If we were able to set our own definitions for what <code>nvam_get()</code> and <code>nvram_set()</code> do, we can effectively control the values that <code>httpd</code> recieves when attempting to interact with the NVRAM through these functions.</p>
<p>That is what <code>nvram-faker</code> does. We can recreate the NVRAM-related procedures called by <code>httpd</code> in <code>nvram-faker.c</code> and compile them into our own library, <code>libnvram-faker.so</code>.</p>
<p>Furthermore, <code>httpd</code> dynamically links the <code>libnvram.so</code> library with the dynamic linker <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">ld</a>. By setting the environment variable <code>LD_PRELOAD</code> to <code>libnvram-faker.so</code>, <code>ld</code> is instructed to load our crafted shared object file before the real <code>libnvram.so</code> library is loaded in. Consequently, the NVRAM-related procedures that we defined in <code>nvram-faker.c</code> (and by extension <code>libnvram-faker.so</code>) will be called instead of the intended symbols in <code>libnvram.so</code>.</p>
<p><code>Nvram-faker</code> is programmed to parse through key-value pairs stored in a <code>/nvram.ini</code> file in the firmware squashfs root. When the target binary calls <code>nvram_get()</code>, the value defined in <code>/nvram.ini</code> for the requested key is returned.</p>
<h1 id="building-nvram-faker">Building Nvram-Faker</h1>
<p>As previously mentioned, the firmware that I am emulating is big-endian, 32-bit ARM. Since <code>libnvram-faker.so</code> will be preloaded into a binary in that firmware, it must match that ARM architecture. This means that I will need to cross-compile our <code>nvram-faker</code>.</p>
<p>Cross-compiling requires a cross-compilation toolchain. ARM offsers plenty of <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">toolchains</a>, however, none of them matched what I was looking for, so I decided to use <a href="https://github.com/crosstool-ng/crosstool-ng">crosstool-ng</a> to compile my own toolchain. You can read their <a href="https://crosstool-ng.github.io/docs/">documentation</a> for more information on how this works.</p>
<h2 id="making-a-cross-compilation-toolchain-with-crosstool-ng">Making a Cross-Compilation Toolchain with Crosstool-ng</h2>
<p>I used the following commands to begin building <code>crosstool-ng</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install help2man libtool-bin <span style="color:#75715e">#dependencies</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/crosstool-ng/crosstool-ng
</span></span><span style="display:flex;"><span>cd crosstool-ng
</span></span><span style="display:flex;"><span>git checkout tags/crosstool-ng-1.26.0
</span></span><span style="display:flex;"><span>./bootstrap
</span></span><span style="display:flex;"><span>./configure --prefix<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$PWD<span style="color:#e6db74">/build&#34;</span>
</span></span><span style="display:flex;"><span>make <span style="color:#f92672">&amp;&amp;</span> make install
</span></span></code></pre></div><p>With the created <code>ct-ng</code> binary, I began to configure my toolchain. Luckily, there was already a sample configuration from <code>armeb-unknown-eabi</code>, which is a match for my target architecture (I was able to tell based on the <a href="https://stackoverflow.com/questions/5731495/can-anyone-explain-the-gcc-cross-compiler-naming-convention/5731708#5731708">toolchain naming conventions</a>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./build/bin/ct-ng show-samples
</span></span><span style="display:flex;"><span>./build/bin/ct-ng show-armeb-unknown-eabi
</span></span><span style="display:flex;"><span>./build/bin/ct-ng armeb-unknown-eabi <span style="color:#75715e"># load it into config</span>
</span></span><span style="display:flex;"><span>./build/bin/ct-ng menuconfig
</span></span></code></pre></div><p>I verified in the menu configuration that the settings for our target toolchain matched what I was expecting for this compilation in the “Target Options” menu.</p>
<p><img loading="lazy" src="/images/nvram-2.png" alt="Picture of the &amp;ldquo;Target Options&amp;rdquo; menu in the ct-ng menuconfig"  />
</p>
<p>I later encountered difficulties with downloading the tarballs needed by <code>crosstool-ng</code>. To resolve this, I configured a mirror: <a href="https://ftp.gnu.org/gnu/">https://ftp.gnu.org/gnu/</a>.</p>
<p><img loading="lazy" src="/images/nvram-5.png" alt="Mirror added to menuconfig"  />
</p>
<p>Future me experienced more errors relating to missing necessary C library header files. To address this, I enabled newlib.</p>
<p><img loading="lazy" src="/images/nvram-6.png" alt="Enabling the newlib C library in the ct-ng menuconfig"  />
</p>
<p>We can now begin to build our target toolchain!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./build/bin/ct-ng build
</span></span></code></pre></div><p>The build process took about 40 minutes and eventually resulted in an error when attempting to compile <code>gdbserver</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>ERROR<span style="color:#f92672">]</span>    configure: error: C compiler cannot create executables
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>CFG  <span style="color:#f92672">]</span>    See <span style="color:#e6db74">`</span>config.log<span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#66d9ef">for</span> more details
</span></span></code></pre></div><p>I was worried that this error may have stopped the target toolchain from being created. I searched within the <code>.build</code> directory of <code>crosstool-ng</code> to check that the target binaries I was looking for were created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ find . -name <span style="color:#e6db74">&#39;*armeb-unknown-eabi*&#39;</span> -type f
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcc.1
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-tool.1
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov.1
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-cpp.1
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-dump.1
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-tool
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ranlib
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-cpp
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ar
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-nm
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-dump
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-13.2.0
</span></span></code></pre></div><p>Perfect, the tools we need have been built. We can use the gdbserver built into QEMU for debugging.  Let’s begin to compile nvram-faker.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/zcutlip/nvram-faker.git
</span></span><span style="display:flex;"><span>cd nvram-faker
</span></span><span style="display:flex;"><span>CC<span style="color:#f92672">=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make
</span></span></code></pre></div><p>Unfortunately, attempting to build nvram-faker with <code>make</code> resulted in two distinct errors. First, the file <code>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o</code> was not found.</p>
<p>Let’s investigate.</p>
<h2 id="troubleshooting-nvram-faker-compilation">Troubleshooting Nvram-Faker Compilation</h2>
<p>Since <code>make</code> appeared to expect <code>crt0.o</code> in a specific location, I figured that changing the search path to include the location that it was actually at would resolve the issue. I began by locating a copy of <code>crt0.o</code> that exists</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ find . -name <span style="color:#e6db74">&#39;crt0.o&#39;</span>
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o
</span></span></code></pre></div><p>Then, I used <code>$CFLAGS</code> such as <code>-I</code> and <code>-L</code> to include the path <code>./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/</code>. I also tried including the <code>crt0.o</code> file directly by manually using the <code>armeb-unkown-eabi-gcc</code> compiler with <code>crt0.o</code> as an input file, but neither of these worked.</p>
<p>I ultimately decided to copy <code>crt0.o</code> to the location that the cross-compiler was searching for it at.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the symlink didn&#39;t work</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ln -s ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o</span>
</span></span><span style="display:flex;"><span>cp ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/crt0.o
</span></span></code></pre></div><p>Now that we&rsquo;ve solved the first error, let&rsquo;s move on to the next!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kali@kali:~/Documents/firmware/nvram-faker$ CC<span style="color:#f92672">=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make
</span></span><span style="display:flex;"><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -ggdb -DINI_MAX_LINE<span style="color:#f92672">=</span><span style="color:#ae81ff">2000</span> -DINI_USE_STACK<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -fPIC -c -o nvram-faker.o nvram-faker.c
</span></span><span style="display:flex;"><span>nvram-faker.c:1:10: fatal error: stdlib.h: No such file or directory
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> | <span style="color:#75715e">#include &lt;stdlib.h&gt;</span>
</span></span><span style="display:flex;"><span>      |          ^~~~~~~~~~
</span></span><span style="display:flex;"><span>compilation terminated.
</span></span><span style="display:flex;"><span>make: *** <span style="color:#f92672">[</span>Makefile:35: nvram-faker.o<span style="color:#f92672">]</span> Error <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>It seems that <code>make</code> was having difficulty with finding our C library. I ended up searching for the <code>stdlib.h</code> header file in the <code>crosstool-ng</code> directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>~/Documents/firmware/crosstool-ng$ find . -name stdlib.h
</span></span><span style="display:flex;"><span>./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/gcc-13.2.0/fixincludes/tests/base/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/gcc-13.2.0/fixincludes/tests/base/ansi/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/gcc-13.2.0/libstdc++-v3/include/tr1/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/gcc-13.2.0/libstdc++-v3/include/c_compatibility/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/ssp/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/machine/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/stdlib.h
</span></span><span style="display:flex;"><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/machine/powerpc/machine/stdlib.h
</span></span></code></pre></div><p>I first tried using the stdlib from <code>./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/</code>, however, this resulted additional errors. My speculation is that the header files in there were intended for my host architecture, x64, and not the target architecture of 32-bit, big-endian ARM.</p>
<p>This was the point that I realized that rebuilding with newlib would solve this problem. This enabled me to include <code>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/</code> as a search directory in our make command via the CFLAGS <code>-I</code> option:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> make CC<span style="color:#f92672">=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-I</span>$HOME<span style="color:#e6db74">/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib&#34;</span>
</span></span></code></pre></div><p>With that, our problems are solved.</p>
<h3 id="compiling-nvram-faker">Compiling nvram-faker.</h3>
<p>Now that we are properly set up for building <code>nvram-faker</code>, let’s run <code>make</code> to create <code>libnvram-faker.so</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make CC<span style="color:#f92672">=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-I</span>$HOME<span style="color:#e6db74">/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib&#34;</span>
</span></span><span style="display:flex;"><span>make: Nothing to be <span style="color:#66d9ef">done</span> <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;all&#39;</span>.
</span></span><span style="display:flex;"><span>$ file ./libnvram-faker.so 
</span></span><span style="display:flex;"><span>./libnvram-faker.so: ELF 32-bit MSB shared object, ARM, EABI5 version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, with debug_info, not stripped
</span></span></code></pre></div><p>The <code>file</code> output is exactly what we want as it matches the other binaries executed on the firmware like busybox:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ file ./bin/busybox 
</span></span><span style="display:flex;"><span>./bin/busybox: ELF 32-bit MSB executable, ARM, EABI5 version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /lib/ld-musl-armeb.so.1, no section header
</span></span></code></pre></div><h3 id="using-nvram-faker">Using nvram-faker</h3>
<p>Now, I’ll copy the libnvram-faker.so file and re-enter the chroot environment at the base of our firmware image’s squashfs file system.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cp ../../nvram-faker/libnvram-faker.so .
</span></span><span style="display:flex;"><span>touch nvram.ini
</span></span></code></pre></div><p>Let&rsquo;s test it!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo chroot . ./qemu-armeb-static /bin/sh -c <span style="color:#e6db74">&#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&#34;</span>
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: __libc_init_array: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: main: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: __heap_limit: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: _impure_ptr: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: _ctype_: symbol not found
</span></span></code></pre></div><p>Hm, it looks like we have some more errors to resolve. Let’s understand why these are happening and address them. Based on the error message, I am going to assume that the linker was expecting the symbols above to be in our library (perhaps as some ABI standard?) and since they were not found, it has difficulty with determining where to place our library in memory. This is just a guess, so feel free to correct me if I’m wrong.</p>
<h3 id="troubleshooting-libnvram-fakerso">Troubleshooting libnvram-faker.so</h3>
<p>I had two ideas that I thought may resolve this by including the expected symbols:</p>
<ol>
<li>Recompiling <code>libnvram-faker.so</code> with our cross-compiled  <code>ld</code>, <code>ar</code>, <code>as</code>, <code>strip</code>, and <code>nm</code> binaries since I did not include these before.
<ul>
<li>This operates on the assumption that including these binaries would automatically create the expected symbols.</li>
</ul>
</li>
<li>Manually patching <code>nvram-faker.c</code> to include the symbols that the linker is expecting.</li>
</ol>
<p>I started out testing the first idea.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ make clean
</span></span><span style="display:flex;"><span>rm *.o
</span></span><span style="display:flex;"><span>rm *.so
</span></span><span style="display:flex;"><span>rm nvram_faker_exe
</span></span><span style="display:flex;"><span>rm: cannot remove <span style="color:#e6db74">&#39;nvram_faker_exe&#39;</span>: No such file or directory
</span></span><span style="display:flex;"><span>make: <span style="color:#f92672">[</span>Makefile:46: clean<span style="color:#f92672">]</span> Error <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>ignored<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>make -C ./contrib/inih clean
</span></span><span style="display:flex;"><span>make<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Entering directory <span style="color:#e6db74">&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style="display:flex;"><span>rm *.o
</span></span><span style="display:flex;"><span>make<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Leaving directory <span style="color:#e6db74">&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ make CC<span style="color:#f92672">=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-I</span>$HOME<span style="color:#e6db74">/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include&#34;</span> LD<span style="color:#f92672">=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ld AR<span style="color:#f92672">=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ar STRIP<span style="color:#f92672">=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-strip NM<span style="color:#f92672">=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-nm 
</span></span><span style="display:flex;"><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o nvram-faker.o nvram-faker.c
</span></span><span style="display:flex;"><span>make -C ./contrib/inih ini.o
</span></span><span style="display:flex;"><span>make<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Entering directory <span style="color:#e6db74">&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style="display:flex;"><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o ini.o ini.c
</span></span><span style="display:flex;"><span>make<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>: Leaving directory <span style="color:#e6db74">&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style="display:flex;"><span>cp ./contrib/inih/ini.o .
</span></span><span style="display:flex;"><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -shared -o libnvram-faker.so nvram-faker.o ini.o -Wl,-nostdlib
</span></span></code></pre></div><p>After copying it back to our squashfs root and trying again, it seems the same issue persists. This rules out incompatible <code>ld</code>, <code>ar</code>, <code>as</code>, <code>strip</code>, or <code>nm</code> binaries as the root cause. I wasn&rsquo;t confident that this would be the solution, but it was worth a shot. Now I know more.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cp ./libnvram-faker.so ../_extracted_firmware/squashfs-root/
</span></span><span style="display:flex;"><span>$ sudo chroot . ./qemu-armeb-static /bin/sh -c <span style="color:#e6db74">&#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&#34;</span>
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: __libc_init_array: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: main: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: __heap_limit: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: _impure_ptr: symbol not found
</span></span><span style="display:flex;"><span>Error relocating /libnvram-faker.so: _ctype_: symbol not found
</span></span></code></pre></div><p>Instead, let’s attempt the second idea. I created <a href="https://github.com/ally-petitt/nvram-faker">my own fork</a> of nvram-faker and got to work.</p>
<p>As I was creating the patch to manually add the expected symbols into <code>nvram-faker.c</code>, I made the observation that many of these symbols were defined in common C libraries like <code>ctypes.h</code> and <code>stdlib.h</code>. This made me suspect that the issue might reside in the flags relating to the C library.</p>
<p>I quickly tried recompiling without the <code>-nostdlib</code> flag by modifying the <code>nvram-faker</code> <code>Makefile</code> and recompiling with the <code>-static</code> flag. Neither of these worked, so I continued with the original plan, which involved appending the following to <code>nvram-faker.c</code> and recompiling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>void main<span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>	write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;libnvram-faker.so has loaded\n&#34;</span>, 29<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>void* initialise_monitor_handles;
</span></span><span style="display:flex;"><span>void* __heap_limit;
</span></span><span style="display:flex;"><span>void <span style="color:#f92672">(</span>*__libc_fini_array<span style="color:#f92672">[])</span> <span style="color:#f92672">(</span>void<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>void <span style="color:#f92672">(</span>*__libc_init_array<span style="color:#f92672">[])</span> <span style="color:#f92672">(</span>void<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>struct _reent * _impure_ptr;
</span></span><span style="display:flex;"><span>char _ctype_;
</span></span></code></pre></div><p>I discovered the data types that work through a combination of compiler warnings and grepping for definitions such as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kali@kali:~/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include$ grep -r <span style="color:#e6db74">&#34;_ctype_&#34;</span> .
</span></span><span style="display:flex;"><span>./ctype.h:extern	__IMPORT const char	_ctype_<span style="color:#f92672">[]</span>;
</span></span></code></pre></div><p>Let’s try to run this again!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ sudo chroot . ./qemu-armeb-static /bin/sh -c <span style="color:#e6db74">&#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&#34;</span>
</span></span><span style="display:flex;"><span>cannot open /dev/nvram
</span></span><span style="display:flex;"><span>httpd : httpd cannot start. ssl and/or http must be selected
</span></span></code></pre></div><p>Well, our library loaded successfully this time, but it’s not quite what we were hoping for. From my prior reverse engineering of interesting libraries in this firmware, I knew that the error message we received comes from <code>libnvram.so</code>, which we can verify with grep.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ grep -r <span style="color:#e6db74">&#34;cannot open /dev/nvram&#34;</span> .
</span></span><span style="display:flex;"><span>Binary file ./lib/libnvram.so matches
</span></span></code></pre></div><h3 id="debugging-libnvram-fakerso">Debugging Libnvram-faker.so</h3>
<p>I wanted to get to the root of why this error message was still appearing despite using <code>libnvram-faker.so</code> to hook NVRAM-related functionality.</p>
<h4 id="attempt-1-gdb">Attempt 1: GDB</h4>
<p>I first attempted to debug using GDB. In QEMU, I used the built-in GDB server to listen on port 1234.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chroot . ./qemu-armeb-static -g <span style="color:#ae81ff">1234</span> -E LD_PRELOAD<span style="color:#f92672">=</span>/libnvram-faker.so /usr/sbin/httpd
</span></span></code></pre></div><p>in another terminal window I modified my <code>.gdbinit</code> file to expidite up the process of connecting and debugging to our target application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat ~/.gdbinit
</span></span><span style="display:flex;"><span>set disassembly-flavor intel
</span></span><span style="display:flex;"><span>set print asm-demangle on
</span></span><span style="display:flex;"><span>source $HOME/Downloads/pwndbg/gdbinit.py
</span></span><span style="display:flex;"><span>set arch arm
</span></span><span style="display:flex;"><span>set follow-fork-mode child
</span></span><span style="display:flex;"><span>target extended-remote :1234
</span></span></code></pre></div><p>Then, I connected to the remote process.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gdb-multiarch ./usr/sbin/httpd
</span></span></code></pre></div><p><img loading="lazy" src="/images/nvram-7.png" alt="Pwndbg context output after connecting to the httpd debugging process"  />
</p>
<p>To make debugging easier, I calculated the offset of the memory addresses in our debugging process to memory addresses in the <code>httpd</code> binary itself. When I ran the <code>load</code> command in GDB with this offset as the second parameter, it made the addresses in the debugger consistent with those in my Ghidra CodeBrowser.</p>
<p>To make this calculation, I subtracted PC (the ARM <a href="https://developer.arm.com/documentation/107656/0101/Registers/Registers-in-the-register-bank/R15--Program-Counter--PC-">program counter register</a>) with the address of the first entry instruction in <code>httpd</code> to adjust our addresses to match that of the binary.</p>
<blockquote>


<p><details >
  <summary markdown="span"><strong>Note on verifying offset</strong></summary>
  I had verified that we were at the first entry instruction by matching the byte sequence that our PC was at (<code>x/3wx $PC</code>) to the hex dump of the <code>httpd</code> entrypoint (made easier through the use of a Ghidra search functionality).
</details></p>

</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pwndbg&gt; load ./usr/sbin/httpd <span style="color:#ae81ff">4286266732</span>
</span></span></code></pre></div><p>This is where the problems with GDB began. There appeared to be an issue with the timing of the program between when I connected to the debugging process and it began execution. If the delay was more than a few milliseconds, the <code>libc_start_main</code> function would have a segmentation fault. I tried automating loading the program and setting breakpoints in <code>.gdbinit</code>, but even this was not fast enough to prevent a segfault.</p>
<p>I don’t know if there was a race condition or something else preventing normal execution. If anyone knows why this may have happened, please do let me know since I am quite puzzled by it.</p>
<p>I asked myself the question, “is there another way to do this?”. I realized what I was really looking for was a call stack for when that error message was printed. I got an idea of how I could recreate this through static analysis.</p>
<h4 id="attempt-2-ghidra">Attempt 2: Ghidra</h4>
<p>I started by pinpointing where our error message appears and checking its implementation in our fake NVRAM library.</p>
<p>In Ghidra, I opened a project with <code>libnvram.so</code> loaded in the CodeBrowser. Using the built-in tool <code>Window &gt; Defined Strings</code>, I was able to search for our error message, “<code>cannot open /dev/nvram</code>.&quot;</p>
<p><img loading="lazy" src="/images/nvram-8.png" alt="Ghidra defined strings window showing our error message"  />
</p>
<p>I followed the location of this string in the binary to reveal that it is referenced in a procedure that Ghidra called <code>FUN_00012420</code>.</p>
<p><img loading="lazy" src="/images/nvram-9.png" alt="The error message in the disassembly of the binary"  />
</p>
<p>This function is called by some of the major functions in <code>libnvram.so</code> such as <code>nvram_get</code>.</p>
<p><img loading="lazy" src="/images/nvram-10.png" alt="The call tree of FUN_00012420"  />
</p>
<p>When quickly listing the NVRAM functions imported in <code>httpd</code>(which there are defined strings for), it does not appear that <code>httpd</code> is calling a libnvram function that would trigger our error. However, that doesn’t mean that a call to this endpoint isn’t abstracted some other way.</p>
<p><img loading="lazy" src="/images/nvram-11.png" alt="Defined strings with &amp;ldquo;nvram&amp;rdquo; in them in &lt;code&gt;httpd&lt;/code&gt;"  />
</p>
<p>I decided to analyze a complete call graph of <code>FUN_00012420</code> (as opposed to the first layer of the call tree), which confirmed my suspicions: <code>nvram_set</code> called a function that called <code>FUN_00012420</code>. This means that <code>nvram_set</code>, a function called by <code>httpd</code>, was very likely the entrypoint to our “<code>cannot find /dev/nvram</code>” error message.</p>
<p><img loading="lazy" src="/images/nvram-12.png" alt="Call graph of FUN_00012420"  />
</p>
<p>As stated in the <code>nvram-faker</code> <a href="https://github.com/zcutlip/nvram-faker?tab=readme-ov-file#using">README</a>:</p>
<blockquote>
<p>The library currently does not support calls to <code>nvram_set()</code>.</p>
</blockquote>
<p>My hypothesis was that since <code>nvram_set()</code> was not defined in the <code>libnvram-faker.so</code> library that we created, it was being imported from <code>libnvram.so</code>. In turn, <code>FUN_00012420</code> is called which attempts to open <code>/dev/nvram</code> and fails (since the kernel module for <code>/dev/nvram</code> does not exist), printing our error message.</p>
<p>To verify that this is the case, I once again patched <code>nvram-faker.c</code>, but this time I implemented a preliminary definition for <code>nvram_set</code> and observe whether the error from before is still present.</p>
<p>The following is what I added to <code>nvram-faker.c</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>char * nvram_set<span style="color:#f92672">(</span>char * key, char * value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;nvram_set called\n&#34;</span>, 17<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>After I compiled and ran <code>httpd</code>, this was my output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo chroot . ./qemu-armeb-static -E LD_PRELOAD<span style="color:#f92672">=</span>/libnvram-faker.so /usr/sbin/httpd
</span></span><span style="display:flex;"><span>nvram_set called
</span></span><span style="display:flex;"><span>httpd : httpd cannot start. ssl and/or http must be selected
</span></span></code></pre></div><p>Perfect! The previous error that <code>/dev/nvram</code> was not found is no longer appearing and in its place is the output that we injected for the <code>nvram_set()</code> function I defined. This verifies that <code>nvram_set</code> was the source of the error messages. Now, we can create our own implementation of <code>nvram_set</code> to enable full functionality of <code>httpd.</code></p>
<p>To streamline the development process, I made my own script to clean, build, and test the library:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>set -e <span style="color:#75715e"># exit on failure</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $# -ne <span style="color:#ae81ff">4</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;Usage: </span>$0<span style="color:#e6db74"> &lt;compilation_toolchain_binaries_path&gt; &lt;squashfs_root_path&gt; &lt;newlib_path&gt; &lt;target_binary_path&gt;&#34;</span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;Example: </span>$0<span style="color:#e6db74"> </span>$HOME<span style="color:#e6db74">/x-tools/armeb-unknown-eabi/bin </span>$HOME<span style="color:#e6db74">/_extracted_firmware/squashfs-root </span>$HOME<span style="color:#e6db74">/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include /usr/sbin/httpd&#34;</span>
</span></span><span style="display:flex;"><span>  exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TOOLCHAIN_PATH<span style="color:#f92672">=</span>$1
</span></span><span style="display:flex;"><span>SQUASHFS_PATH<span style="color:#f92672">=</span>$2
</span></span><span style="display:flex;"><span>NEWLIB_PATH<span style="color:#f92672">=</span>$3
</span></span><span style="display:flex;"><span>TARGET_BINARY<span style="color:#f92672">=</span>$4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>make clean
</span></span><span style="display:flex;"><span>make CC<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>TOOLCHAIN_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">/armeb-unknown-eabi-gcc&#34;</span> CFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-DDEBUG=1 -I</span><span style="color:#e6db74">${</span>NEWLIB_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> LD<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>TOOLCHAIN_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">/armeb-unknown-eabi-ld AR=</span><span style="color:#e6db74">${</span>TOOLCHAIN_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">/armeb-unknown-eabi-ar STRIP=</span><span style="color:#e6db74">${</span>TOOLCHAIN_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">/armeb-unknown-eabi-strip NM=</span><span style="color:#e6db74">${</span>TOOLCHAIN_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">/armeb-unknown-eabi-nm&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cp ./libnvram-faker.so <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>SQUASHFS_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>sudo chroot <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>SQUASHFS_PATH<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> ./qemu-armeb-static -E LD_PRELOAD<span style="color:#f92672">=</span>/libnvram-faker.so <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>TARGET_BINARY<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>I encountered a segmentation fault when debug was enabled due to how <code>fprintf</code> was being used to log debug output through the <code>DEBUG_PRINTF</code> macro. I ended up redefining <code>DEBUG_PRINTF</code> and <code>LOG_PRINTF</code> to be based on <code>printf</code> instead of <code>fprintf</code> to prevent the segfault.</p>
<blockquote>


<p><details >
  <summary markdown="span"><strong>Expand to learn why fprintf was originally used instead of printf</strong></summary>
  After a bit of digging, I would discover that <code>fprintf()</code> was used for debug and log output in the original <code>nvram-faker</code> repository as a workaround to how <code>stdout</code> was being redirected after <code>system()</code> was called in the webserver it was used to emulate. As explained in the <a href="https://shadowfile.inode.link/blog/2015/01/patching-emulating-and-debugging-a-netgear-embedded-web-server/">author’s blogpost</a>, <code>fprintf()</code> allowed him to print to <code>stderr</code>, which was visible in the console, unlike the output of <code>printf()</code> that goes to <code>stdout</code> and was not visible after <code>system()</code> was called.
</details></p>

</blockquote>
<h3 id="adding-support-for-nvram_set">Adding Support for nvram_set</h3>
<p>It was originally my intention to add <code>nvram_set()</code> support to <code>nvram-faker.c</code> in order to fully mimic a real NVRAM interaction, however, an event came up in my personal life that delayed this. I may endeavor to do so in the future when the timing is better, however, for now I have opted to simply create my <a href="https://github.com/ally-petitt/nvram-faker">own fork</a> with the following improvements on the old one:</p>
<ul>
<li>More informative debug output</li>
<li>Resolve segmentation fault in debugging output</li>
<li>Added additional symbols to <code>nvram-faker.c</code> such as <code>initialise_monitor_handles</code> and <code>__libc_fini_array</code> to avoid linking errors</li>
<li>Add a preliminary <code>nvram_set()</code> function that logs debug output to prevent function calls to <code>libnvram.so</code></li>
<li>Add a <code>build_and_run.sh</code> script to streamline development and testing</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<p>From here, you can simply create and populate an <code>nvram.ini</code> file at the root of your extracted firmware filesystem and add the keys-value pairs that your target application expects! There are many ways to figure out these expected values. For instance, you can run the target application and view the NVRAM values it requests in the debugging output. You can also reverse engineer the target application to see the values it expects.</p>
<p>Here is an excerpt from the <code>nvram-faker</code> example <a href="https://github.com/zcutlip/nvram-faker/blob/master/nvram.ini">nvram.ini</a> file for reference:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>[config]
</span></span><span style="display:flex;"><span>os_name=linux
</span></span><span style="display:flex;"><span>os_version=1
</span></span><span style="display:flex;"><span>upnp_port=9999
</span></span><span style="display:flex;"><span>upnp_ad_time=30
</span></span><span style="display:flex;"><span>upnp_sub_timeout=60
</span></span><span style="display:flex;"><span>upnp_conn_retries=10
</span></span><span style="display:flex;"><span>log_level=10
</span></span><span style="display:flex;"><span>lan_hwaddr=52:54:00:12:34:58
</span></span><span style="display:flex;"><span>lan_ifname=eth0
</span></span><span style="display:flex;"><span>lan1_ifname=wlan0
</span></span></code></pre></div><h1 id="conclusion">Conclusion</h1>
<p>This article was quite lengthy and technical compared to what I normally put out. It really started as me wanting to test out a chroot sandbox on a router and escalated into emulating a webserver and needing a way to interface with NVRAM. This was a great exercise that taught me more about cross-compilation, NVRAM, and general troubleshooting. Past me would have been overwhelmed by the amount of errors that I had to work through to get this to work (this article didn&rsquo;t even detail half of them for brevity), so working through this helped to strengthen my perserverance as a researcher.</p>
<p>Overall, this was an interesting rabbit hole to go down. I hope it made as much sense in text as it did in my head. If any details in here were inaccurate, please feel free to contact me and I will be happy to correct the information in this article.</p>
<p>Thanks for reading!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Beyond the Screen: The Hidden World of Firmware Security</title>
      <link>https://ally-petitt.com:443/en/posts/2023-08-05_beyond-the-screen--the-hidden-world-of-firmware-security-87b0ea6a20a4/</link>
      <pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://ally-petitt.com:443/en/posts/2023-08-05_beyond-the-screen--the-hidden-world-of-firmware-security-87b0ea6a20a4/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*UA4-sPgJH7Fhk9jbvvRafQ.jpeg&#34; alt=&#34;https://www.istockphoto.com/photo/man-using-laptop-with-update-software-computer-program-upgrade-business-technology-gm1449779856-486876929&#34;  /&gt;

Introduction&lt;/h1&gt;
&lt;p&gt;Firmware is a critical component of electronic devices. It is the program that is installed on embedded systems that defines their functionality. Firmware is responsible for initializing the hardware components as the computer boots up, enabling the device to function properly.&lt;/p&gt;
&lt;p&gt;Attacks against firmware have been of increasing interest to hackers due to their relative ease to exploit in a world of increasingly more secure application- and network-layer security practices. Firmware security has been a frequently overlooked attack surface in cybersecurity that is now relatively unprotected in comparison to other attack vectors such as web applications or operating systems.&lt;/p&gt;
&lt;p&gt;In addition, security mitigations such as performing firmware updates are often more costly and inconvenient as they may require updating other software and firmware dependencies on the system, leading to more downtime. In some environments such as hospitals, firmware must pass very strict regulations which can increase the time it takes for updates. Compatibility between the firmware and hardware can result in an additional barrier for firmware updates.&lt;/p&gt;
&lt;h1 id=&#34;the-rise-of-firmwareattacks&#34;&gt;The Rise of Firmware Attacks&lt;/h1&gt;
&lt;p&gt;Firmware attacks are quickly becoming more common. According to &lt;a href=&#34;https://www.microsoft.com/en-us/security/blog/2021/03/30/new-security-signals-study-shows-firmware-attacks-on-the-rise-heres-how-microsoft-is-working-to-help-eliminate-this-entire-class-of-threats/&#34;&gt;Microsoft&lt;/a&gt;, 80% of organizations between the years 2019 and 2021 were victims to at least 1 firmware attack. In many cases, firmware is a single point of failure in the devices of organizations. The privileged nature of firmware allows for it to be abused by cybercriminals to access information such as cryptographic keys in memory, the BIOS/UEFI memory, network traffic, and potentially data from peripheral devices such as SSDs or webcams.&lt;/p&gt;
&lt;p&gt;These are some of the techniques used by adversaries once they have obtained firmware-level access:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disable security settings such as Secure Boot (&lt;a href=&#34;https://thehackernews.com/2023/03/blacklotus-becomes-first-uefi-bootkit.html&#34;&gt;BlackLotus&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Modify the boot record of the system to contain a bootkit&lt;/li&gt;
&lt;li&gt;Wipe the boot record resulting in a bricked system&lt;/li&gt;
&lt;li&gt;Arbitrarily read secrets and other sensitive data from memory&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;attack-surface&#34;&gt;Attack Surface&lt;/h1&gt;
&lt;p&gt;Attacking firmware can lead to extremely privileged access to a system. For instance, Baseboard Management Controllers (BMCs), Unified Extensible Firmware Interface (UEFI), System Management Mode (SMMs), or management subsystems on the CPU can each be compromised. This section will outline each component’s purpose, security risk, and mitigation techniques.&lt;/p&gt;
&lt;h2 id=&#34;bmcs&#34;&gt;BMCs&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*9hEnbp2Z7WCO9WKV&#34; alt=&#34;&#34;  /&gt;

Baseboard Management Controllers (BMCs) are hardware components that are often soldered into the motherboard of enterprise-grade servers. They may be assigned different names depending on the model that is used. For instance, Dell’s high end PowerEdge servers refer to the BMC as iDRAC (Dell Remote Access Controller) and HP has their infamous iLO (integrated Lights Out) which, as the name implies, provides out-of-band remote management services for the server that allow it to run in a lights out data center with minimal physical interaction.&lt;/p&gt;
&lt;p&gt;The role of BMCs is to allow remote management of the server. This includes power management, which is the ability to turn the server off and on, and the ability to configure UEFI settings. They often include a built-in keyboard video mouse (KVM) functionality that allows out-of-band access to the display of the server and allows for direct interaction with it through a keyboard and mouse.&lt;/p&gt;
&lt;p&gt;BMCs are highly privileged components that may be abused for&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data theft and exfiltration&lt;/li&gt;
&lt;li&gt;Malware installation&lt;/li&gt;
&lt;li&gt;Disabling security features such as Secure Boot&lt;/li&gt;
&lt;li&gt;Physical damage to the system caused by sending it a signal that increases the voltage to the CPU causing it to overheat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another attack might include incessant rebooting of the system, rendering it temporarily useless and leading to a loss of availability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mitigation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BMC attacks can be mitigated through the following techniques:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Establishing unique user accounts (if possible) and setting a strong password- ideally one that is in line with &lt;a href=&#34;https://pages.nist.gov/800-63-3/sp800-63b.html&#34;&gt;NIST’s password guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Enforcing secure network practices such as not exposing the BMC to the internet and implementing VLAN separation&lt;/li&gt;
&lt;li&gt;Use firmware scanning tools to verify the integrity of the firmware and catch security misconfigurations&lt;/li&gt;
&lt;li&gt;Monitoring BMC integrity through an established root of trust (RoT) such as a TPM or secure enclave in the CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uefibios&#34;&gt;UEFI/BIOS&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*B3RibWe5mxvLNeKh&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;Picture of a BIOS screen&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The Unified Extensible Firmware Interface (UEFI) is the modern and prevalent successor to the Basic Input Output System (BIOS).&lt;/p&gt;
&lt;p&gt;With access to the UEFI, attackers can&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wipe the UEFI — the resulting hardware would need to be sent back to the hardware to be flashed with the correct firmware again&lt;/li&gt;
&lt;li&gt;Firmware modification&lt;/li&gt;
&lt;li&gt;Bootkit installation&lt;/li&gt;
&lt;li&gt;Physical damage to the system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An infamous example of malware that attacks the UEFI is &lt;a href=&#34;https://thehackernews.com/2023/03/blacklotus-becomes-first-uefi-bootkit.html&#34;&gt;BlackLotus&lt;/a&gt;, a bootkit that abused &lt;a href=&#34;https://github.com/Wack0/CVE-2022-21894&#34;&gt;CVE-2022–21894&lt;/a&gt; to truncate the SecureBoot policy from memory via the Windows Boot Application, thereby fully bypassing the security measure. Malware with the level of access granted by the UEFI can result in expensive damages to enterprise systems.&lt;/p&gt;
&lt;h2 id=&#34;smms&#34;&gt;SMMs&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*J6wRzq-WjDenWZ3v.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2020/11/SMM-social-2.png&#34;&gt;https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2020/11/SMM-social-2.png&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The System Management Mode (&lt;a href=&#34;https://en.wikipedia.org/wiki/System_Management_Mode&#34;&gt;SMM&lt;/a&gt;) is a highly privileged operating mode that is often referred to as Ring -2. The primary benefit of SMM is that it offers a distinct processor environment that is meant for use by only the UEFI/BIOS. The SMM code is executed in its own isolated address space known as SMRAM that is inaccessible to other privilege levels. This isolation is enforced by firmware.&lt;/p&gt;
&lt;p&gt;When System Manager Interrupts (SMIs) are issued during runtime, they interrupt the current execution of the CPU and transfer control to the SMI Handler, which is a software routine stored in the firmware that is responsible for handling and processing these interrupts. SMIs are how the UEFI interacts with the SMM.&lt;/p&gt;
&lt;p&gt;SMMs can be abused to&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implant rootkits and bootkits on a system&lt;/li&gt;
&lt;li&gt;Read sensitive data&lt;/li&gt;
&lt;li&gt;Maintain persistence and stealth&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Mitigation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mitigations for SMM attacks can include keeping the firmware updated and using security mechanisms such as Data Execution Prevention (DEP) and Control-Flow Integrity (CFI) on compiled binaries to protect from memory-based attacks.&lt;/p&gt;
&lt;h2 id=&#34;management-subsystems&#34;&gt;Management Subsystems&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*5XuFmJUmVLjZnmpG&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://freundschafter.com/wp-content/uploads/2018/01/7254-f-4-bc8a6355cce759c3.png&#34;&gt;https://freundschafter.com/wp-content/uploads/2018/01/7254-f-4-bc8a6355cce759c3.png&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Intel’s &lt;a href=&#34;https://en.wikipedia.org/wiki/Intel_Management_Engine&#34;&gt;Management Engine&lt;/a&gt; (ME) or AMD’s &lt;a href=&#34;https://en.wikipedia.org/wiki/AMD_Secure_Technology&#34;&gt;Platform Security Processor&lt;/a&gt; (PSP) are standalone microcontroller components that allow for out-of-band, remote management of a computer. They are included in the chipsets of these CPUs and, as explained in &lt;a href=&#34;https://freundschafter.com/research/about-intel-management-engine-intel-me-intel-active-management-technlogy-iamt/&#34;&gt;this article&lt;/a&gt;, the ME of an Intel chip in particular has a separated connection from the internal Interconnect, means it has the capabilities to bypass other subsystems like TPM and SMBus.&lt;/p&gt;
&lt;p&gt;The ME contains the Intel Active Management Technology (AMT). The AMT provides the remote management and control capabilities for Intel-based computers and servers, even when the system is powered off or the operating system is not running. It is a service that is enabled by the hardware microcontroller that is referred to as the ME.&lt;/p&gt;
&lt;p&gt;Despite ME and BMCs having a similar functionality, BMCs are not implemented into the same variety and scale of devices as the management engine is. This can significantly increase the impact of an ME vulnerability.&lt;/p&gt;
&lt;p&gt;Well known vulnerabilities in the ME include &lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2018-3627&#34;&gt;CVE-2018–3627&lt;/a&gt; and &lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2020-8703&#34;&gt;CVE-2020–8703&lt;/a&gt; which can lead to arbitrary code execution and local privilege escalation respectively.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mitigation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Keeping the software of the CPU updated is crucial for mitigation. The updates can contain patches for known security vulnerabilities on the ME of the chip. In particular, updating the CSME, AMT, I ISM, DAL and DAL Software can prevent vulnerabilities as well as securely configuring the management engine if possible.&lt;/p&gt;
&lt;h1 id=&#34;supply-chainattacks&#34;&gt;Supply Chain Attacks&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*3iEBRxmvxyY1JJnKj1V-Yw.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://www.enisa.europa.eu/news/enisa-news/understanding-the-increase-in-supply-chain-security-attacks/@@download/image/IncidentReporting-PR_423x300mm_01.png&#34;&gt;https://www.enisa.europa.eu/news/enisa-news/understanding-the-increase-in-supply-chain-security-attacks/@@download/image/IncidentReporting-PR_423x300mm_01.png&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Attacking the supply chain can involve tampering with the firmware or hardware at any stage in the supply chain including development, manufacturing, distribution, and updating or patching the system. The result can be widely distributed malware affecting countless systems.&lt;/p&gt;
&lt;p&gt;In addition to the aforementioned tampering, firmware often uses 3rd-party dependencies (e.g. &lt;a href=&#34;https://binarly.io/posts/OpenSSL_Usage_in_UEFI_Firmware_Exposes_Weakness_in_SBOMs/index.html&#34;&gt;OpenSSL&lt;/a&gt;) which can remain outdated even when included in the latest firmware version. The result is a discrepancy between the firmware and its dependencies which never received an update, despite having critical security vulnerabilities.&lt;/p&gt;
&lt;p&gt;One method used to manage supply chain dependencies is using a Software Bill of Materials (SBOM). This is a list of the software components that are implemented into a firmware component. The accuracy and integrity of these lists are crucial to ensure that the known vulnerabilities in the firmware’s dependencies can be identified. There are also commercial solutions that monitor the firmware’s activity and integrity in order to raise alerts when suspicious hallmarks of infected firmware are detected.&lt;/p&gt;
&lt;h1 id=&#34;malware-attacks&#34;&gt;Malware Attacks&lt;/h1&gt;
&lt;p&gt;Another way that firmware can be exploited is through a system that has already been infected. This may happen through social engineering, executing a malicious program, exploiting vulnerabilities in externally facing service, drive-by attacks, and other initial access methods identified by the &lt;a href=&#34;https://attack.mitre.org/&#34;&gt;MITRE ATT&amp;amp;CK framework&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this attack type, the malicious actor or malware will attempt to elevate their privileges to the highest possible level and use tools such as &lt;a href=&#34;http://rweverything.com/&#34;&gt;RWEverything&lt;/a&gt; to write to the drivers and firmware. Through this approach, attackers are still able to obtain the privileged access of and stealth granted through firmware-level access.&lt;/p&gt;
&lt;h1 id=&#34;firmware-attacks-in-thewild&#34;&gt;Firmware Attacks in the Wild&lt;/h1&gt;
&lt;p&gt;It has become increasingly more prevalent for adversaries to gain their initial foothold on a network through remote access products. In 2020 alone, &lt;a href=&#34;https://www.checkpoint.com/downloads/resources/cyber-security-report-2021.pdf&#34;&gt;Checkpoint’s annual&lt;/a&gt; cybersecurity report found a substantial increases ranging from 85% to 2,066% of attacks that exploit vulnerabilities in these products as shown in the image below.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*Mx8XRA2YeI3His7r24yFuQ.png&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;Page 25 of Checkpoint’s 2021 cybersecurity report&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Many of these vulnerabilities are caused by insecure firmware. Examples of this in insecure VPN products are &lt;a href=&#34;https://www.bleepingcomputer.com/news/security/zyxel-warns-of-critical-vulnerabilities-in-firewall-and-vpn-devices/&#34;&gt;Zyxel&lt;/a&gt;’s &lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2023-33009&#34;&gt;CVE-2023–33009&lt;/a&gt; and &lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2023-33010&#34;&gt;CVE-2023–33010&lt;/a&gt; and Fortinet’s &lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2023-27997&#34;&gt;CVE-2023–27997&lt;/a&gt;. Both are critical RCEs caused by a buffer overflow that can lead to unauthorized, highly privileged access to a device. This can then be abused to implant malware such as a bootkit or make other critical configuration changes to the system and to move laterally through the internal network.&lt;/p&gt;
&lt;h1 id=&#34;mitigations&#34;&gt;Mitigations&lt;/h1&gt;
&lt;h2 id=&#34;security-platforms&#34;&gt;Security Platforms&lt;/h2&gt;
&lt;p&gt;Firmware security platforms such as those offered by &lt;a href=&#34;https://binarly.io/&#34;&gt;Binarly&lt;/a&gt; and &lt;a href=&#34;https://eclypsium.com/&#34;&gt;Eclypsium&lt;/a&gt; can help to detect and mitigate firmware misconfigurations and vulnerabilities. Binarly relies primarily on AI and deep code inspection to detect known and unknown vulnerabilities and misconfigurations in firmware. Eclypsium’s approach appears to incorporate both crytographic and heuristic verification of firmware with continuous monitoring, although the exact approach of both of these solutions is unknown.&lt;/p&gt;
&lt;p&gt;In addition, Lenovo launched their &lt;a href=&#34;https://techtoday.lenovo.com/us/en/solutions/thinkshield&#34;&gt;ThinkShield&lt;/a&gt; earlier this week, which is also powered by Eclypsium. A testament to the increase in availability of commercial solutions in firmware and supply chain security.&lt;/p&gt;
&lt;h2 id=&#34;code-signing&#34;&gt;Code Signing&lt;/h2&gt;
&lt;p&gt;Solutions that use cryptographic signatures to verify the integrity of code can also be used to mitigate supply chain attacks. Unforeseen malware being added to production code, for instance, can be prevented since the changes after the program was signed would be easier to detect.&lt;/p&gt;
&lt;p&gt;For instance, &lt;a href=&#34;https://www.sigstore.dev&#34;&gt;Sigstore&lt;/a&gt; is an open source project that at a high level uses Public Key Infrastructure (PKI) in order to validate the integrity of different modules in the supply chain to ensure that they were not tampered with. It does this by using a Sigstore client such as Cosign to request a public and private key from the certificate authority Fulcio. The private key that was obtained is used with Cosign to sign the file or image to be verified. After the artifact is signed, the signature of the file, its digest, and public key are stored in Rekor, an append-only transparency ledger that is viewable by the public. The private key is then deleted automatically, removing the need for key management. This system allows for developers, security professionals, and end users to verify that the file they have has not been tampered with.&lt;/p&gt;
&lt;p&gt;It is worth noting, however, that while code signing will verify integrity, it does not guarantee that the Software Bill of Materials (SBOM) is fully accurate in its content and completeness in closed-source projects. The security implication is potential lack of transparency on 3rd-party dependencies in these projects leading to unpatched security vulnerabilities in the system.&lt;/p&gt;
&lt;h1 id=&#34;initiatives&#34;&gt;Initiatives&lt;/h1&gt;
&lt;p&gt;While firmware attacks are on the rise, there is hope to be found in the initiatives that have been enacted in order to fortify this section of cybersecurity.&lt;/p&gt;
&lt;h2 id=&#34;increased-firmware-publications&#34;&gt;Increased Firmware Publications&lt;/h2&gt;
&lt;p&gt;There has been a rising awareness of firmware security that can be attributed largely to the increased amount of publications in circulation. These may include security best practices, vulnerability disclosures, or news articles.&lt;/p&gt;
&lt;p&gt;In June of this year, the Cybersecurity &amp;amp; Infrastructure Security Agency (CISA) and the National Security Agency (NSA) collaborated to create a guide for &lt;a href=&#34;https://media.defense.gov/2023/Jun/14/2003241405/-1/-1/0/CSI_HARDEN_BMCS.PDF&#34;&gt;hardening baseboard management controllers&lt;/a&gt;. This document outlined best practices for securing BMCs including many of the techniques that were mentioned previously in this article.&lt;/p&gt;
&lt;h2 id=&#34;ssith&#34;&gt;SSITH&lt;/h2&gt;
&lt;p&gt;In 2017, Defense Advanced Research Projects Agency (DARPA) created their System Security Integration Through Hardware and Firmware (&lt;a href=&#34;https://www.darpa.mil/program/ssith&#34;&gt;SSITH&lt;/a&gt;) program which takes a proactive approach to low-level security.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SSITH is focusing specifically on common classes of hardware weaknesses as identified by the MITRE Common Weakness Enumeration Specification (CWE) and NIST, including buffer errors; information leakage; resource management; numeric errors; injection; permissions, privileges, and access control; and hardware/system-on-chip implementation errors. Researchers are exploring a number of different approaches that go well beyond patching. These include using metadata tagging to detect unauthorized system access; utilizing context sensing pipelines to determine the intent of instructions; and employing formal methods to reason about integrated circuit systems and guarantee the accuracy of security characteristics.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.darpa.mil/program/ssith&#34;&gt;Dr. Lok Yan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Although it does have a predominant focus on hardware, SSITH still recognizes the role of firmware as an essential component in addressing security challenges and preventing exploit.&lt;/p&gt;
&lt;p&gt;SSITH appears to be an ongoing program whose effects have not yet been released publicly.&lt;/p&gt;
&lt;h2 id=&#34;secure-development-practices&#34;&gt;Secure Development Practices&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn-images-1.medium.com/max/800/0*h4xdnj8S3XpVFr8o.jpg&#34; alt=&#34;&#34;  /&gt;

&lt;em&gt;&lt;a href=&#34;https://blog.gitguardian.com/content/images/2022/05/21W10-blog-content-stateOfReport-image2.jpg&#34;&gt;https://blog.gitguardian.com/content/images/2022/05/21W10-blog-content-stateOfReport-image2.jpg&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Cybersecurity has gradually become a significant part of the development process of both software and firmware. More companies are making the shift to a Secure Software Development Lifecycle (SSDLC). With this model, security is a consideration from the conception of a program to its release.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;With firmware attacks on the rise and an increased reliance on digital devices, securing systems is an important step of preventing critical cyberattacks. Modern commercial solutions can help to monitor firmware configurations, activity, and supply chain vulnerabilities and the trend towards secure development and education can help to decrease the amount of vulnerabilities that are in the firmware to begin with. In spite of this, firmware will likely never reach a point of having zero vulnerabilities. Maintaining regular updates and continuous education on the latest research is imperative in safeguarding our digital ecosystems, fortifying devices against emerging threats, and fostering a resilient foundation for a secure and trustworthy technological future.&lt;/p&gt;
</description>
      <content:encoded><![CDATA[<h1 id="introduction"><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/1*UA4-sPgJH7Fhk9jbvvRafQ.jpeg" alt="https://www.istockphoto.com/photo/man-using-laptop-with-update-software-computer-program-upgrade-business-technology-gm1449779856-486876929"  />

Introduction</h1>
<p>Firmware is a critical component of electronic devices. It is the program that is installed on embedded systems that defines their functionality. Firmware is responsible for initializing the hardware components as the computer boots up, enabling the device to function properly.</p>
<p>Attacks against firmware have been of increasing interest to hackers due to their relative ease to exploit in a world of increasingly more secure application- and network-layer security practices. Firmware security has been a frequently overlooked attack surface in cybersecurity that is now relatively unprotected in comparison to other attack vectors such as web applications or operating systems.</p>
<p>In addition, security mitigations such as performing firmware updates are often more costly and inconvenient as they may require updating other software and firmware dependencies on the system, leading to more downtime. In some environments such as hospitals, firmware must pass very strict regulations which can increase the time it takes for updates. Compatibility between the firmware and hardware can result in an additional barrier for firmware updates.</p>
<h1 id="the-rise-of-firmwareattacks">The Rise of Firmware Attacks</h1>
<p>Firmware attacks are quickly becoming more common. According to <a href="https://www.microsoft.com/en-us/security/blog/2021/03/30/new-security-signals-study-shows-firmware-attacks-on-the-rise-heres-how-microsoft-is-working-to-help-eliminate-this-entire-class-of-threats/">Microsoft</a>, 80% of organizations between the years 2019 and 2021 were victims to at least 1 firmware attack. In many cases, firmware is a single point of failure in the devices of organizations. The privileged nature of firmware allows for it to be abused by cybercriminals to access information such as cryptographic keys in memory, the BIOS/UEFI memory, network traffic, and potentially data from peripheral devices such as SSDs or webcams.</p>
<p>These are some of the techniques used by adversaries once they have obtained firmware-level access:</p>
<ul>
<li>Disable security settings such as Secure Boot (<a href="https://thehackernews.com/2023/03/blacklotus-becomes-first-uefi-bootkit.html">BlackLotus</a>)</li>
<li>Modify the boot record of the system to contain a bootkit</li>
<li>Wipe the boot record resulting in a bricked system</li>
<li>Arbitrarily read secrets and other sensitive data from memory</li>
</ul>
<h1 id="attack-surface">Attack Surface</h1>
<p>Attacking firmware can lead to extremely privileged access to a system. For instance, Baseboard Management Controllers (BMCs), Unified Extensible Firmware Interface (UEFI), System Management Mode (SMMs), or management subsystems on the CPU can each be compromised. This section will outline each component’s purpose, security risk, and mitigation techniques.</p>
<h2 id="bmcs">BMCs</h2>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/0*9hEnbp2Z7WCO9WKV" alt=""  />

Baseboard Management Controllers (BMCs) are hardware components that are often soldered into the motherboard of enterprise-grade servers. They may be assigned different names depending on the model that is used. For instance, Dell’s high end PowerEdge servers refer to the BMC as iDRAC (Dell Remote Access Controller) and HP has their infamous iLO (integrated Lights Out) which, as the name implies, provides out-of-band remote management services for the server that allow it to run in a lights out data center with minimal physical interaction.</p>
<p>The role of BMCs is to allow remote management of the server. This includes power management, which is the ability to turn the server off and on, and the ability to configure UEFI settings. They often include a built-in keyboard video mouse (KVM) functionality that allows out-of-band access to the display of the server and allows for direct interaction with it through a keyboard and mouse.</p>
<p>BMCs are highly privileged components that may be abused for</p>
<ul>
<li>Data theft and exfiltration</li>
<li>Malware installation</li>
<li>Disabling security features such as Secure Boot</li>
<li>Physical damage to the system caused by sending it a signal that increases the voltage to the CPU causing it to overheat</li>
</ul>
<p>Another attack might include incessant rebooting of the system, rendering it temporarily useless and leading to a loss of availability.</p>
<p><strong>Mitigation</strong></p>
<p>BMC attacks can be mitigated through the following techniques:</p>
<ul>
<li>Establishing unique user accounts (if possible) and setting a strong password- ideally one that is in line with <a href="https://pages.nist.gov/800-63-3/sp800-63b.html">NIST’s password guidelines</a></li>
<li>Enforcing secure network practices such as not exposing the BMC to the internet and implementing VLAN separation</li>
<li>Use firmware scanning tools to verify the integrity of the firmware and catch security misconfigurations</li>
<li>Monitoring BMC integrity through an established root of trust (RoT) such as a TPM or secure enclave in the CPU</li>
</ul>
<h2 id="uefibios">UEFI/BIOS</h2>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/0*B3RibWe5mxvLNeKh" alt=""  />

<em>Picture of a BIOS screen</em></p>
<p>The Unified Extensible Firmware Interface (UEFI) is the modern and prevalent successor to the Basic Input Output System (BIOS).</p>
<p>With access to the UEFI, attackers can</p>
<ul>
<li>Wipe the UEFI — the resulting hardware would need to be sent back to the hardware to be flashed with the correct firmware again</li>
<li>Firmware modification</li>
<li>Bootkit installation</li>
<li>Physical damage to the system</li>
</ul>
<p>An infamous example of malware that attacks the UEFI is <a href="https://thehackernews.com/2023/03/blacklotus-becomes-first-uefi-bootkit.html">BlackLotus</a>, a bootkit that abused <a href="https://github.com/Wack0/CVE-2022-21894">CVE-2022–21894</a> to truncate the SecureBoot policy from memory via the Windows Boot Application, thereby fully bypassing the security measure. Malware with the level of access granted by the UEFI can result in expensive damages to enterprise systems.</p>
<h2 id="smms">SMMs</h2>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/0*J6wRzq-WjDenWZ3v.png" alt=""  />

<em><a href="https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2020/11/SMM-social-2.png">https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2020/11/SMM-social-2.png</a></em></p>
<p>The System Management Mode (<a href="https://en.wikipedia.org/wiki/System_Management_Mode">SMM</a>) is a highly privileged operating mode that is often referred to as Ring -2. The primary benefit of SMM is that it offers a distinct processor environment that is meant for use by only the UEFI/BIOS. The SMM code is executed in its own isolated address space known as SMRAM that is inaccessible to other privilege levels. This isolation is enforced by firmware.</p>
<p>When System Manager Interrupts (SMIs) are issued during runtime, they interrupt the current execution of the CPU and transfer control to the SMI Handler, which is a software routine stored in the firmware that is responsible for handling and processing these interrupts. SMIs are how the UEFI interacts with the SMM.</p>
<p>SMMs can be abused to</p>
<ul>
<li>Implant rootkits and bootkits on a system</li>
<li>Read sensitive data</li>
<li>Maintain persistence and stealth</li>
</ul>
<p><strong>Mitigation</strong></p>
<p>Mitigations for SMM attacks can include keeping the firmware updated and using security mechanisms such as Data Execution Prevention (DEP) and Control-Flow Integrity (CFI) on compiled binaries to protect from memory-based attacks.</p>
<h2 id="management-subsystems">Management Subsystems</h2>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/0*5XuFmJUmVLjZnmpG" alt=""  />

<em><a href="https://freundschafter.com/wp-content/uploads/2018/01/7254-f-4-bc8a6355cce759c3.png">https://freundschafter.com/wp-content/uploads/2018/01/7254-f-4-bc8a6355cce759c3.png</a></em></p>
<p>Intel’s <a href="https://en.wikipedia.org/wiki/Intel_Management_Engine">Management Engine</a> (ME) or AMD’s <a href="https://en.wikipedia.org/wiki/AMD_Secure_Technology">Platform Security Processor</a> (PSP) are standalone microcontroller components that allow for out-of-band, remote management of a computer. They are included in the chipsets of these CPUs and, as explained in <a href="https://freundschafter.com/research/about-intel-management-engine-intel-me-intel-active-management-technlogy-iamt/">this article</a>, the ME of an Intel chip in particular has a separated connection from the internal Interconnect, means it has the capabilities to bypass other subsystems like TPM and SMBus.</p>
<p>The ME contains the Intel Active Management Technology (AMT). The AMT provides the remote management and control capabilities for Intel-based computers and servers, even when the system is powered off or the operating system is not running. It is a service that is enabled by the hardware microcontroller that is referred to as the ME.</p>
<p>Despite ME and BMCs having a similar functionality, BMCs are not implemented into the same variety and scale of devices as the management engine is. This can significantly increase the impact of an ME vulnerability.</p>
<p>Well known vulnerabilities in the ME include <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-3627">CVE-2018–3627</a> and <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-8703">CVE-2020–8703</a> which can lead to arbitrary code execution and local privilege escalation respectively.</p>
<p><strong>Mitigation</strong></p>
<p>Keeping the software of the CPU updated is crucial for mitigation. The updates can contain patches for known security vulnerabilities on the ME of the chip. In particular, updating the CSME, AMT, I ISM, DAL and DAL Software can prevent vulnerabilities as well as securely configuring the management engine if possible.</p>
<h1 id="supply-chainattacks">Supply Chain Attacks</h1>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/1*3iEBRxmvxyY1JJnKj1V-Yw.png" alt=""  />

<em><a href="https://www.enisa.europa.eu/news/enisa-news/understanding-the-increase-in-supply-chain-security-attacks/@@download/image/IncidentReporting-PR_423x300mm_01.png">https://www.enisa.europa.eu/news/enisa-news/understanding-the-increase-in-supply-chain-security-attacks/@@download/image/IncidentReporting-PR_423x300mm_01.png</a></em></p>
<p>Attacking the supply chain can involve tampering with the firmware or hardware at any stage in the supply chain including development, manufacturing, distribution, and updating or patching the system. The result can be widely distributed malware affecting countless systems.</p>
<p>In addition to the aforementioned tampering, firmware often uses 3rd-party dependencies (e.g. <a href="https://binarly.io/posts/OpenSSL_Usage_in_UEFI_Firmware_Exposes_Weakness_in_SBOMs/index.html">OpenSSL</a>) which can remain outdated even when included in the latest firmware version. The result is a discrepancy between the firmware and its dependencies which never received an update, despite having critical security vulnerabilities.</p>
<p>One method used to manage supply chain dependencies is using a Software Bill of Materials (SBOM). This is a list of the software components that are implemented into a firmware component. The accuracy and integrity of these lists are crucial to ensure that the known vulnerabilities in the firmware’s dependencies can be identified. There are also commercial solutions that monitor the firmware’s activity and integrity in order to raise alerts when suspicious hallmarks of infected firmware are detected.</p>
<h1 id="malware-attacks">Malware Attacks</h1>
<p>Another way that firmware can be exploited is through a system that has already been infected. This may happen through social engineering, executing a malicious program, exploiting vulnerabilities in externally facing service, drive-by attacks, and other initial access methods identified by the <a href="https://attack.mitre.org/">MITRE ATT&amp;CK framework</a>.</p>
<p>With this attack type, the malicious actor or malware will attempt to elevate their privileges to the highest possible level and use tools such as <a href="http://rweverything.com/">RWEverything</a> to write to the drivers and firmware. Through this approach, attackers are still able to obtain the privileged access of and stealth granted through firmware-level access.</p>
<h1 id="firmware-attacks-in-thewild">Firmware Attacks in the Wild</h1>
<p>It has become increasingly more prevalent for adversaries to gain their initial foothold on a network through remote access products. In 2020 alone, <a href="https://www.checkpoint.com/downloads/resources/cyber-security-report-2021.pdf">Checkpoint’s annual</a> cybersecurity report found a substantial increases ranging from 85% to 2,066% of attacks that exploit vulnerabilities in these products as shown in the image below.</p>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/1*Mx8XRA2YeI3His7r24yFuQ.png" alt=""  />

<em>Page 25 of Checkpoint’s 2021 cybersecurity report</em></p>
<p>Many of these vulnerabilities are caused by insecure firmware. Examples of this in insecure VPN products are <a href="https://www.bleepingcomputer.com/news/security/zyxel-warns-of-critical-vulnerabilities-in-firewall-and-vpn-devices/">Zyxel</a>’s <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-33009">CVE-2023–33009</a> and <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-33010">CVE-2023–33010</a> and Fortinet’s <a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27997">CVE-2023–27997</a>. Both are critical RCEs caused by a buffer overflow that can lead to unauthorized, highly privileged access to a device. This can then be abused to implant malware such as a bootkit or make other critical configuration changes to the system and to move laterally through the internal network.</p>
<h1 id="mitigations">Mitigations</h1>
<h2 id="security-platforms">Security Platforms</h2>
<p>Firmware security platforms such as those offered by <a href="https://binarly.io/">Binarly</a> and <a href="https://eclypsium.com/">Eclypsium</a> can help to detect and mitigate firmware misconfigurations and vulnerabilities. Binarly relies primarily on AI and deep code inspection to detect known and unknown vulnerabilities and misconfigurations in firmware. Eclypsium’s approach appears to incorporate both crytographic and heuristic verification of firmware with continuous monitoring, although the exact approach of both of these solutions is unknown.</p>
<p>In addition, Lenovo launched their <a href="https://techtoday.lenovo.com/us/en/solutions/thinkshield">ThinkShield</a> earlier this week, which is also powered by Eclypsium. A testament to the increase in availability of commercial solutions in firmware and supply chain security.</p>
<h2 id="code-signing">Code Signing</h2>
<p>Solutions that use cryptographic signatures to verify the integrity of code can also be used to mitigate supply chain attacks. Unforeseen malware being added to production code, for instance, can be prevented since the changes after the program was signed would be easier to detect.</p>
<p>For instance, <a href="https://www.sigstore.dev">Sigstore</a> is an open source project that at a high level uses Public Key Infrastructure (PKI) in order to validate the integrity of different modules in the supply chain to ensure that they were not tampered with. It does this by using a Sigstore client such as Cosign to request a public and private key from the certificate authority Fulcio. The private key that was obtained is used with Cosign to sign the file or image to be verified. After the artifact is signed, the signature of the file, its digest, and public key are stored in Rekor, an append-only transparency ledger that is viewable by the public. The private key is then deleted automatically, removing the need for key management. This system allows for developers, security professionals, and end users to verify that the file they have has not been tampered with.</p>
<p>It is worth noting, however, that while code signing will verify integrity, it does not guarantee that the Software Bill of Materials (SBOM) is fully accurate in its content and completeness in closed-source projects. The security implication is potential lack of transparency on 3rd-party dependencies in these projects leading to unpatched security vulnerabilities in the system.</p>
<h1 id="initiatives">Initiatives</h1>
<p>While firmware attacks are on the rise, there is hope to be found in the initiatives that have been enacted in order to fortify this section of cybersecurity.</p>
<h2 id="increased-firmware-publications">Increased Firmware Publications</h2>
<p>There has been a rising awareness of firmware security that can be attributed largely to the increased amount of publications in circulation. These may include security best practices, vulnerability disclosures, or news articles.</p>
<p>In June of this year, the Cybersecurity &amp; Infrastructure Security Agency (CISA) and the National Security Agency (NSA) collaborated to create a guide for <a href="https://media.defense.gov/2023/Jun/14/2003241405/-1/-1/0/CSI_HARDEN_BMCS.PDF">hardening baseboard management controllers</a>. This document outlined best practices for securing BMCs including many of the techniques that were mentioned previously in this article.</p>
<h2 id="ssith">SSITH</h2>
<p>In 2017, Defense Advanced Research Projects Agency (DARPA) created their System Security Integration Through Hardware and Firmware (<a href="https://www.darpa.mil/program/ssith">SSITH</a>) program which takes a proactive approach to low-level security.</p>
<blockquote>
<p>SSITH is focusing specifically on common classes of hardware weaknesses as identified by the MITRE Common Weakness Enumeration Specification (CWE) and NIST, including buffer errors; information leakage; resource management; numeric errors; injection; permissions, privileges, and access control; and hardware/system-on-chip implementation errors. Researchers are exploring a number of different approaches that go well beyond patching. These include using metadata tagging to detect unauthorized system access; utilizing context sensing pipelines to determine the intent of instructions; and employing formal methods to reason about integrated circuit systems and guarantee the accuracy of security characteristics.</p>
<ul>
<li><a href="https://www.darpa.mil/program/ssith">Dr. Lok Yan</a></li>
</ul>
</blockquote>
<p>Although it does have a predominant focus on hardware, SSITH still recognizes the role of firmware as an essential component in addressing security challenges and preventing exploit.</p>
<p>SSITH appears to be an ongoing program whose effects have not yet been released publicly.</p>
<h2 id="secure-development-practices">Secure Development Practices</h2>
<p><img loading="lazy" src="https://cdn-images-1.medium.com/max/800/0*h4xdnj8S3XpVFr8o.jpg" alt=""  />

<em><a href="https://blog.gitguardian.com/content/images/2022/05/21W10-blog-content-stateOfReport-image2.jpg">https://blog.gitguardian.com/content/images/2022/05/21W10-blog-content-stateOfReport-image2.jpg</a></em></p>
<p>Cybersecurity has gradually become a significant part of the development process of both software and firmware. More companies are making the shift to a Secure Software Development Lifecycle (SSDLC). With this model, security is a consideration from the conception of a program to its release.</p>
<h1 id="conclusion">Conclusion</h1>
<p>With firmware attacks on the rise and an increased reliance on digital devices, securing systems is an important step of preventing critical cyberattacks. Modern commercial solutions can help to monitor firmware configurations, activity, and supply chain vulnerabilities and the trend towards secure development and education can help to decrease the amount of vulnerabilities that are in the firmware to begin with. In spite of this, firmware will likely never reach a point of having zero vulnerabilities. Maintaining regular updates and continuous education on the latest research is imperative in safeguarding our digital ecosystems, fortifying devices against emerging threats, and fostering a resilient foundation for a secure and trustworthy technological future.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
