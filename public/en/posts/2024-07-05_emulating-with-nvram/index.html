<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to Use NVRAM When Emulating an Embedded Device | Ally Petitt</title>
<meta name=keywords content="Firmware,Debugging"><meta name=description content="Introduction Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, httpd, that I was targeting. A smile spread across my face as I typed a command into the terminal to run httpd in QEMU user mode, but after pressing the “Enter” key, I saw it:"><meta name=author content="Ally Petitt"><link rel=canonical href=https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://ally-petitt.com:443/assets/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ally-petitt.com:443/assets/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ally-petitt.com:443/assets/favicon-32x32.png><link rel=apple-touch-icon href=https://ally-petitt.com:443/assets/apple-touch-icon.png><link rel=mask-icon href=https://ally-petitt.com:443/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How to Use NVRAM When Emulating an Embedded Device"><meta property="og:description" content="Introduction Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, httpd, that I was targeting. A smile spread across my face as I typed a command into the terminal to run httpd in QEMU user mode, but after pressing the “Enter” key, I saw it:"><meta property="og:type" content="article"><meta property="og:url" content="https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-05T00:00:00+00:00"><meta property="og:site_name" content="Ally Petitt"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to Use NVRAM When Emulating an Embedded Device"><meta name=twitter:description content="Introduction Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, httpd, that I was targeting. A smile spread across my face as I typed a command into the terminal to run httpd in QEMU user mode, but after pressing the “Enter” key, I saw it:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ally-petitt.com:443/en/posts/"},{"@type":"ListItem","position":2,"name":"How to Use NVRAM When Emulating an Embedded Device","item":"https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to Use NVRAM When Emulating an Embedded Device","name":"How to Use NVRAM When Emulating an Embedded Device","description":"Introduction Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, httpd, that I was targeting. A smile spread across my face as I typed a command into the terminal to run httpd in QEMU user mode, but after pressing the “Enter” key, I saw it:","keywords":["Firmware","Debugging"],"articleBody":"Introduction Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, httpd, that I was targeting. A smile spread across my face as I typed a command into the terminal to run httpd in QEMU user mode, but after pressing the “Enter” key, I saw it:\n$ sudo chroot . ./qemu-armeb-static /usr/sbin/httpd -n cannot open /dev/nvram Cannot open /dev/nvram. This error highlights a somewhat common obstacle when emulating embedded devices. Interacting with NVRAM can be an important step in the expected execution of an application, which can be made even more complicated when emulating a device.\nThe Solution In this article, I’ll walk through one method that I used to hook into the functions that request and set data from /dev/nvram, enabling me to intercept and modify interactions with the NVRAM while my target application runs. This allows us to have more granular control of the values returned by calls to the NVRAM so that we can return our desired values. As a result, the application runs smoothly as though an NVRAM device actually existed on the system. Think of it like a man-in-the-middle attack on NVRAM that our target application is oblivious to.\nNote: By “target application” or “target binary”, I am referring to the binary that is being emulated in QEMU and relies on the NVRAM. In my specific case, this is httpd in my extracted firmware.\nThis article aims to walk you through my thought process in approaching this rather than solely offering a copy-paste solution. I have found reading other researcher’s thought processes to be helpful in the past and was hoping to pay it forward. As such, my troubleshooting steps and some of my (failed) ideas are included.\nTLDR; I built an instance of crosstool-ng to create an armeb-unknown-eabi toolchain. This was necessary for me to cross-compile nvram-faker in the target architecture: big endian, 32-bit ARM. Nvram-faker allowed us to hijack function calls originally intended for libnvram.so, which is a library used to interface with /dev/nvram, through the LD_PRELOAD variable. I ended up patching nvram-faker in my own fork to solve dynamic linking issues and solve a bug that caused a segfault.\nDisclaimer I am just a hobbyist. There are likely more efficient and/or robust ways to add support for NVRAM when emulating firmware with QEMU. This is just one of the solutions that I came across on my own. All the information in the article is accurate to the best of my knowledge and has the chance to be incorrect. I have done my best to fact-check the information presented.\nWhat is NVRAM? NVRAM, or non-volatile RAM, is a type of computer memory that maintains the values stored within it after the computer has been turned off and on again. Often, the NVRAM contains configuration information that can help direct applications during the boot process or runtime. It is almost like a Solid-State Drive (SSD), but with far less storage capacity, increased speed, and it is generally soldered onto the motherboard.\nSetup The following table shows a high-level overview of the firmware I am dealing with.\nArchitecture ARMv5 (armeb) Chipset IXP425 ABI EABI5 Operating System OpenWRT Endianess Big Endian Goal: Run the binary /usr/sbin/httpd in our firmware image.\nProblem: httpd relies on NVRAM for configuration data. Since we are emulating in QEMU, we do not have the physical NVRAM to provide this data, so httpd is unable to initialize.\nPotential Solutions:\nCreate a custom kernel module to respond with the expected values at /dev/nvram. This can be more complex and would require reverse engineering of libnvram.so to understand how /dev/nvram expects to be interacted with in order to recreate the appropriate interface. Building a specific implementation for this firmware may be less portable to other firmware images compared to our 2nd possible solution. Hook function calls to libnvram.so and override their return value. Potentially faster to implement. There is already an open-source project called nvram-faker that can be used as a starting point. Needless to say, I’ll be exploring solution 2 in this article. Although, I am open to creating the kernel module if it is requested since I can see if having educational value.\nNvram faker Nvram-faker is a GitHub project created by Zachary Cutlip in 2013 to “intercept calls to libnvram when running embedded linux applications in emulated environments.” Despite its old age, Nvram-faker is still very usable for today’s use cases.\nHow it Works Our httpd binary does not attempt to access /dev/nvram, the NVRAM device file in the firmware, directly. Instead, it uses a shared object file called libnvram.so in order to abstract interaction with NVRAM. This dependency on libnvram.so is evident in the “About” window on httpd in Ghidra.\nYes, my Ghidra is in dark mode.\nThe httpd program imports functions like nvram_get() and nvram_set() from libnvram.so that manage interactions with /dev/nvram. If we were able to set our own definitions for what nvam_get() and nvram_set() do, we can effectively control the values that httpd receives when attempting to interact with the NVRAM through these functions.\nThat is what nvram-faker does. We can recreate the NVRAM-related procedures called by httpd in nvram-faker.c and compile them into our own library, libnvram-faker.so.\nFurthermore, httpd dynamically links the libnvram.so library with the dynamic linker ld. By setting the environment variable LD_PRELOAD to libnvram-faker.so, ld is instructed to load our crafted shared object file before the real libnvram.so library is loaded in. Consequently, the NVRAM-related procedures that we defined in nvram-faker.c (and by extension libnvram-faker.so) will be called instead of the intended symbols in libnvram.so.\nNvram-faker is programmed to parse through key-value pairs stored in a /nvram.ini file in the firmware squashfs root. When the target binary calls nvram_get(), the value defined in /nvram.ini for the requested key is returned.\nBuilding Nvram-Faker As previously mentioned, the firmware that I am emulating is big-endian, 32-bit ARM. Since libnvram-faker.so will be preloaded into a binary in that firmware, it must match that ARM architecture. This means that I will need to cross-compile our nvram-faker.\nCross-compiling requires a cross-compilation toolchain. ARM offers plenty of toolchains, however, none of them matched what I was looking for, so I decided to use crosstool-ng to compile my own toolchain. You can read their documentation for more information on how this works.\nMaking a Cross-Compilation Toolchain with Crosstool-ng I used the following commands to begin building crosstool-ng:\nsudo apt install help2man libtool-bin #dependencies git clone https://github.com/crosstool-ng/crosstool-ng cd crosstool-ng git checkout tags/crosstool-ng-1.26.0 ./bootstrap ./configure --prefix=\"$PWD/build\" make \u0026\u0026 make install With the created ct-ng binary, I began to configure my toolchain. Luckily, there was already a sample configuration from armeb-unknown-eabi, which is a match for my target architecture (I was able to tell based on the toolchain naming conventions):\n./build/bin/ct-ng show-samples ./build/bin/ct-ng show-armeb-unknown-eabi ./build/bin/ct-ng armeb-unknown-eabi # load it into config ./build/bin/ct-ng menuconfig I verified in the menu configuration that the settings for our target toolchain matched what I was expecting for this compilation in the “Target Options” menu.\nI later encountered difficulties with downloading the tarballs needed by crosstool-ng. To resolve this, I configured a mirror: https://ftp.gnu.org/gnu/.\nFuture me experienced more errors relating to missing necessary C library header files. To address this, I enabled newlib.\nWe can now begin to build our target toolchain!\n./build/bin/ct-ng build The build process took about 40 minutes and eventually resulted in an error when attempting to compile gdbserver:\n[ERROR] configure: error: C compiler cannot create executables [CFG ] See `config.log' for more details I was worried that this error may have stopped the target toolchain from being created. I searched within the .build directory of crosstool-ng to check that the target binaries I was looking for were created.\n$ find . -name '*armeb-unknown-eabi*' -type f ./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcc.1 ./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-tool.1 ./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov.1 ./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-cpp.1 ./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-dump.1 ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-tool ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ranlib ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-cpp ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ar ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-nm ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-dump ./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-13.2.0 Perfect, the tools we need have been built. We can use the gdbserver built into QEMU for debugging. Let’s begin to compile nvram-faker.\ngit clone https://github.com/zcutlip/nvram-faker.git cd nvram-faker CC=$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make Unfortunately, attempting to build nvram-faker with make resulted in two distinct errors. First, the file $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o was not found.\nLet’s investigate.\nTroubleshooting Nvram-Faker Compilation Since make appeared to expect crt0.o in a specific location, I figured that changing the search path to include the location that it was actually at would resolve the issue. I began by locating a copy of crt0.o that exists\n$ find . -name 'crt0.o' ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o Then, I used $CFLAGS such as -I and -L to include the path ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/. I also tried including the crt0.o file directly by manually using the armeb-unkown-eabi-gcc compiler with crt0.o as an input file, but neither of these worked.\nI ultimately decided to copy crt0.o to the location that the cross-compiler was searching for it.\nmkdir -p $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib # the symlink didn't work #ln -s ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o cp ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/crt0.o Now that we’ve solved the first error, let’s move on to the next!\nkali@kali:~/Documents/firmware/nvram-faker$ CC=$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -ggdb -DINI_MAX_LINE=2000 -DINI_USE_STACK=0 -fPIC -c -o nvram-faker.o nvram-faker.c nvram-faker.c:1:10: fatal error: stdlib.h: No such file or directory 1 | #include | ^~~~~~~~~~ compilation terminated. make: *** [Makefile:35: nvram-faker.o] Error 1 It seems that make was having difficulty with finding our C library. I ended up searching for the stdlib.h header file in the crosstool-ng directory.\n~/Documents/firmware/crosstool-ng$ find . -name stdlib.h ./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/stdlib.h ./.build/src/gcc-13.2.0/fixincludes/tests/base/stdlib.h ./.build/src/gcc-13.2.0/fixincludes/tests/base/ansi/stdlib.h ./.build/src/gcc-13.2.0/libstdc++-v3/include/tr1/stdlib.h ./.build/src/gcc-13.2.0/libstdc++-v3/include/c_compatibility/stdlib.h ./.build/src/newlib-4.3.0.20230120/newlib/libc/include/ssp/stdlib.h ./.build/src/newlib-4.3.0.20230120/newlib/libc/include/machine/stdlib.h ./.build/src/newlib-4.3.0.20230120/newlib/libc/include/stdlib.h ./.build/src/newlib-4.3.0.20230120/newlib/libc/machine/powerpc/machine/stdlib.h I first tried using the stdlib from ./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/, however, this resulted additional errors. My speculation is that the header files in there were intended for my host architecture, x64, and not the target architecture of 32-bit, big-endian ARM.\nThis was the point that I realized that rebuilding with newlib would solve this problem. This enabled me to include ./.build/src/newlib-4.3.0.20230120/newlib/libc/include/ as a search directory in our make command via the CFLAGS -I option:\nmake CC=$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS=\"-I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib\" With that, our problems are solved.\nCompiling nvram-faker. Now that we are properly set up for building nvram-faker, let’s run make to create libnvram-faker.so.\n$ make CC=$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS=\"-I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib\" make: Nothing to be done for 'all'. $ file ./libnvram-faker.so ./libnvram-faker.so: ELF 32-bit MSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, with debug_info, not stripped The file output is exactly what we want as it matches the other binaries executed on the firmware like busybox:\nkali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ file ./bin/busybox ./bin/busybox: ELF 32-bit MSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-armeb.so.1, no section header Using nvram-faker Now, I’ll copy the libnvram-faker.so file and re-enter the chroot environment at the base of our firmware image’s squashfs file system.\ncp ../../nvram-faker/libnvram-faker.so . touch nvram.ini Let’s test it!\n$ sudo chroot . ./qemu-armeb-static /bin/sh -c \"LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd\" Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found Error relocating /libnvram-faker.so: __libc_init_array: symbol not found Error relocating /libnvram-faker.so: main: symbol not found Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found Error relocating /libnvram-faker.so: __heap_limit: symbol not found Error relocating /libnvram-faker.so: _impure_ptr: symbol not found Error relocating /libnvram-faker.so: _ctype_: symbol not found Hm, it looks like we have some more errors to resolve. Let’s understand why these are happening and address them. Based on the error message, I am going to assume that the linker was expecting the symbols above to be in our library (perhaps as some ABI standard?) and since they were not found, it has difficulty with determining where to place our library in memory. This is just a guess, so feel free to correct me if I’m wrong.\nTroubleshooting libnvram-faker.so I had two ideas that I thought may resolve this by including the expected symbols:\nRecompiling libnvram-faker.so with our cross-compiled ld, ar, as, strip, and nm binaries since I did not include these before. This operates on the assumption that including these binaries would automatically create the expected symbols. Manually patching nvram-faker.c to include the symbols that the linker is expecting. I started out testing the first idea.\n$ make clean rm *.o rm *.so rm nvram_faker_exe rm: cannot remove 'nvram_faker_exe': No such file or directory make: [Makefile:46: clean] Error 1 (ignored) make -C ./contrib/inih clean make[1]: Entering directory '$HOME/Documents/firmware/nvram-faker/contrib/inih' rm *.o make[1]: Leaving directory '$HOME/Documents/firmware/nvram-faker/contrib/inih' $ make CC=$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS=\"-I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include\" LD=$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ld AR=$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ar STRIP=$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-strip NM=$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-nm $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o nvram-faker.o nvram-faker.c make -C ./contrib/inih ini.o make[1]: Entering directory '$HOME/Documents/firmware/nvram-faker/contrib/inih' $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o ini.o ini.c make[1]: Leaving directory '$HOME/Documents/firmware/nvram-faker/contrib/inih' cp ./contrib/inih/ini.o . $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -shared -o libnvram-faker.so nvram-faker.o ini.o -Wl,-nostdlib After copying it back to our squashfs root and trying again, it seems the same issue persists. This rules out incompatible ld, ar, as, strip, or nm binaries as the root cause. I wasn’t confident that this would be the solution, but it was worth a shot. Now I know more.\n$ cp ./libnvram-faker.so ../_extracted_firmware/squashfs-root/ $ sudo chroot . ./qemu-armeb-static /bin/sh -c \"LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd\" Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found Error relocating /libnvram-faker.so: __libc_init_array: symbol not found Error relocating /libnvram-faker.so: main: symbol not found Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found Error relocating /libnvram-faker.so: __heap_limit: symbol not found Error relocating /libnvram-faker.so: _impure_ptr: symbol not found Error relocating /libnvram-faker.so: _ctype_: symbol not found Instead, let’s attempt the second idea. I created my own fork of nvram-faker and got to work.\nAs I was creating the patch to manually add the expected symbols into nvram-faker.c, I made the observation that many of these symbols were defined in common C libraries like ctypes.h and stdlib.h. This made me suspect that the issue might reside in the flags relating to the C library.\nI quickly tried recompiling without the -nostdlib flag by modifying the nvram-faker Makefile and recompiling with the -static flag. Neither of these worked, so I continued with the original plan, which involved appending the following to nvram-faker.c and recompiling:\nvoid main(){ write(1, \"libnvram-faker.so has loaded\\n\", 29); } void* initialise_monitor_handles; void* __heap_limit; void (*__libc_fini_array[]) (void); void (*__libc_init_array[]) (void); struct _reent * _impure_ptr; char _ctype_; I discovered the data types that work through a combination of compiler warnings and grepping for definitions such as:\nkali@kali:~/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include$ grep -r \"_ctype_\" . ./ctype.h:extern\t__IMPORT const char\t_ctype_[]; Let’s try to run this again!\nkali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ sudo chroot . ./qemu-armeb-static /bin/sh -c \"LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd\" cannot open /dev/nvram httpd : httpd cannot start. ssl and/or http must be selected Well, our library loaded successfully this time, but it’s not quite what we were hoping for. From my prior reverse engineering of interesting libraries in this firmware, I knew that the error message we received comes from libnvram.so, which we can verify with grep.\n$ grep -r \"cannot open /dev/nvram\" . Binary file ./lib/libnvram.so matches Debugging Libnvram-faker.so I wanted to get to the root of why this error message was still appearing despite using libnvram-faker.so to hook NVRAM-related functionality.\nAttempt 1: GDB I first attempted to debug using GDB. In QEMU, I used the built-in GDB server to listen on port 1234.\nsudo chroot . ./qemu-armeb-static -g 1234 -E LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd In another terminal window I modified my .gdbinit file to expedite the process of connecting and debugging to our target application.\n$ cat ~/.gdbinit set disassembly-flavor intel set print asm-demangle on source $HOME/Downloads/pwndbg/gdbinit.py set arch arm set follow-fork-mode child target extended-remote :1234 Then, I connected to the remote process.\ngdb-multiarch ./usr/sbin/httpd To make debugging easier, I calculated the offset of the memory addresses in our debugging process to memory addresses in the httpd binary itself. When I ran the load command in GDB with this offset as the second parameter, it made the addresses in the debugger consistent with those in my Ghidra CodeBrowser.\nTo make this calculation, I subtracted PC (the ARM program counter register) with the address of the first entry instruction in httpd to adjust our addresses to match that of the binary.\nNote on verifying offset I had verified that we were at the first entry instruction by matching the byte sequence that our PC was at (x/3wx $PC) to the hex dump of the httpd entrypoint (made easier through the use of a Ghidra search functionality). pwndbg\u003e load ./usr/sbin/httpd 4286266732 This is where the problems with GDB began. There appeared to be an issue with the timing of the program between when I connected to the debugging process and it began execution. If the delay was more than a few milliseconds, the libc_start_main function would have a segmentation fault. I tried automating loading the program and setting breakpoints in .gdbinit, but even this was not fast enough to prevent a segfault.\nI don’t know if there was a race condition or something else preventing normal execution. If anyone knows why this may have happened, please do let me know since I am quite puzzled by it.\nI asked myself the question, “Is there another way to do this?”. I realized what I was really looking for was a call stack for when that error message was printed. I got an idea of how I could recreate this through static analysis.\nAttempt 2: Ghidra I started by pinpointing where our error message appears and checking its implementation in our fake NVRAM library.\nIn Ghidra, I opened a project with libnvram.so loaded in the CodeBrowser. Using the built-in tool Window \u003e Defined Strings, I was able to search for our error message, “cannot open /dev/nvram.\"\nI followed the location of this string in the binary to reveal that it is referenced in a procedure that Ghidra called FUN_00012420.\nThis function is called by some of the major functions in libnvram.so such as nvram_get.\nWhen quickly listing the NVRAM functions imported in httpd(which there are defined strings for), it does not appear that httpd is calling a libnvram function that would trigger our error. However, that doesn’t mean that a call to this endpoint isn’t abstracted some other way.\nI decided to analyze a complete call graph of FUN_00012420 (as opposed to the first layer of the call tree), which confirmed my suspicions: nvram_set called a function that called FUN_00012420. This means that nvram_set, a function called by httpd, was very likely the entrypoint to our “cannot find /dev/nvram” error message.\nAs stated in the nvram-faker README:\nThe library currently does not support calls to nvram_set().\nMy hypothesis was that since nvram_set() was not defined in the libnvram-faker.so library that we created, it was being imported from libnvram.so. In turn, FUN_00012420 is called which attempts to open /dev/nvram and fails (since the kernel module for /dev/nvram does not exist), printing our error message.\nTo verify that this is the case, I once again patched nvram-faker.c, but this time I implemented a preliminary definition for nvram_set and observed whether the error from before is still present.\nThe following is what I added to nvram-faker.c:\nchar * nvram_set(char * key, char * value) { write(1, \"nvram_set called\\n\", 17); } After I compiled and ran httpd, this was my output:\n$ sudo chroot . ./qemu-armeb-static -E LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd nvram_set called httpd : httpd cannot start. ssl and/or http must be selected Perfect! The previous error that /dev/nvram was not found is no longer appearing and in its place is the output that we injected for the nvram_set() function I defined. This verifies that nvram_set was the source of the error messages. Now, we can create our own implementation of nvram_set to enable full functionality of httpd.\nTo streamline the development process, I made my own script to clean, build, and test the library:\n#!/bin/bash set -e # exit on failure if [ $# -ne 4 ]; then echo \"Usage: $0 \" echo \"Example: $0 $HOME/x-tools/armeb-unknown-eabi/bin $HOME/_extracted_firmware/squashfs-root $HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include /usr/sbin/httpd\" exit 1 fi TOOLCHAIN_PATH=$1 SQUASHFS_PATH=$2 NEWLIB_PATH=$3 TARGET_BINARY=$4 make clean make CC=\"${TOOLCHAIN_PATH}/armeb-unknown-eabi-gcc\" CFLAGS=\"-DDEBUG=1 -I${NEWLIB_PATH}\" LD=\"${TOOLCHAIN_PATH}/armeb-unknown-eabi-ld AR=${TOOLCHAIN_PATH}/armeb-unknown-eabi-ar STRIP=${TOOLCHAIN_PATH}/armeb-unknown-eabi-strip NM=${TOOLCHAIN_PATH}/armeb-unknown-eabi-nm\" cp ./libnvram-faker.so \"${SQUASHFS_PATH}\" sudo chroot \"${SQUASHFS_PATH}\" ./qemu-armeb-static -E LD_PRELOAD=/libnvram-faker.so \"${TARGET_BINARY}\" I encountered a segmentation fault when debug was enabled due to how fprintf was being used to log debug output through the DEBUG_PRINTF macro. I ended up redefining DEBUG_PRINTF and LOG_PRINTF to be based on printf instead of fprintf to prevent the segfault.\nExpand to learn why fprintf was originally used instead of printf After a bit of digging, I would discover that fprintf() was used for debug and log output in the original nvram-faker repository as a workaround to how stdout was being redirected after system() was called in the webserver it was used to emulate. As explained in the author’s blogpost, fprintf() allowed him to print to stderr, which was visible in the console, unlike the output of printf() that goes to stdout and was not visible after system() was called. Adding Support for nvram_set It was originally my intention to add nvram_set() support to nvram-faker.c to fully mimic a real NVRAM interaction, however, an event came up in my personal life that delayed this. I may endeavor to do so in the future when the timing is better, however, for now I have opted to simply create my own fork with the following improvements on the old one:\nMore informative debug output Resolve segmentation fault in debugging output Added additional symbols to nvram-faker.c such as initialise_monitor_handles and __libc_fini_array to avoid linking errors Add a preliminary nvram_set() function that logs debug output to prevent function calls to libnvram.so Add a build_and_run.sh script to streamline development and testing Next Steps From here, you can simply create and populate an nvram.ini file at the root of your extracted firmware filesystem and add the keys-value pairs that your target application expects! There are many ways to figure out these expected values. For instance, you can run the target application and view the NVRAM values it requests in the debugging output. You can also reverse engineer the target application to see the values it expects.\nHere is an excerpt from the nvram-faker example nvram.ini file for reference:\n[config] os_name=linux os_version=1 upnp_port=9999 upnp_ad_time=30 upnp_sub_timeout=60 upnp_conn_retries=10 log_level=10 lan_hwaddr=52:54:00:12:34:58 lan_ifname=eth0 lan1_ifname=wlan0 Conclusion This article was quite lengthy and technical compared to what I normally put out. It started as me wanting to test out a chroot sandbox on a router and escalated into emulating a webserver and needing a way to interface with NVRAM. This was a great exercise that taught me more about cross-compilation, NVRAM, and general troubleshooting. One year ago, I would have been overwhelmed by the amount of errors that I encountered while getting this to work (this article detailed less than half of them for brevity), so working through this helped to strengthen my perseverance as a researcher.\nOverall, this was an interesting rabbit hole to go down. I hope it made as much sense in the text as it did in my head. If any details here are inaccurate, please feel free to contact me and I will be happy to correct the information in this article.\nThanks for reading!\n","wordCount":"3780","inLanguage":"en","datePublished":"2024-07-05T00:00:00Z","dateModified":"2024-07-05T00:00:00Z","author":{"@type":"Person","name":"Ally Petitt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ally-petitt.com:443/en/posts/2024-07-05_emulating-with-nvram/"},"publisher":{"@type":"Organization","name":"Ally Petitt","logo":{"@type":"ImageObject","url":"https://ally-petitt.com:443/assets/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ally-petitt.com:443/en/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ally-petitt.com:443/en/archives title=Archive><span>Archive</span></a></li><li><a href=https://ally-petitt.com:443/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ally-petitt.com:443/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ally-petitt.com:443/en/about-me/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ally-petitt.com:443/en/>Home</a>&nbsp;»&nbsp;<a href=https://ally-petitt.com:443/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How to Use NVRAM When Emulating an Embedded Device</h1><div class=post-meta><span title='2024-07-05 00:00:00 +0000 UTC'>2024-07-05</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Ally Petitt</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#the-solution aria-label="The Solution">The Solution</a></li><li><a href=#disclaimer aria-label=Disclaimer>Disclaimer</a></li></ul></li><li><a href=#what-is-nvram aria-label="What is NVRAM?">What is NVRAM?</a></li><li><a href=#setup aria-label=Setup>Setup</a></li><li><a href=#nvram-faker aria-label="Nvram faker">Nvram faker</a><ul><li><a href=#how-it-works aria-label="How it Works">How it Works</a></li></ul></li></ul><li><a href=#building-nvram-faker aria-label="Building Nvram-Faker">Building Nvram-Faker</a><ul><li><a href=#making-a-cross-compilation-toolchain-with-crosstool-ng aria-label="Making a Cross-Compilation Toolchain with Crosstool-ng">Making a Cross-Compilation Toolchain with Crosstool-ng</a></li><li><a href=#troubleshooting-nvram-faker-compilation aria-label="Troubleshooting Nvram-Faker Compilation">Troubleshooting Nvram-Faker Compilation</a><ul><li><a href=#compiling-nvram-faker aria-label="Compiling nvram-faker.">Compiling nvram-faker.</a></li><li><a href=#using-nvram-faker aria-label="Using nvram-faker">Using nvram-faker</a></li><li><a href=#troubleshooting-libnvram-fakerso aria-label="Troubleshooting libnvram-faker.so">Troubleshooting libnvram-faker.so</a></li><li><a href=#debugging-libnvram-fakerso aria-label="Debugging Libnvram-faker.so">Debugging Libnvram-faker.so</a><ul><li><a href=#attempt-1-gdb aria-label="Attempt 1: GDB">Attempt 1: GDB</a></li><li><a href=#attempt-2-ghidra aria-label="Attempt 2: Ghidra">Attempt 2: Ghidra</a></li></ul></li><li><a href=#adding-support-for-nvram_set aria-label="Adding Support for nvram_set">Adding Support for nvram_set</a></li></ul></li><li><a href=#next-steps aria-label="Next Steps">Next Steps</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Last week, I came across a piece of firmware that I was particularly curious about. As with typical analysis on such an image, I extracted the squashfs root using binwalk and found the web service, <code>httpd</code>, that I was targeting. A smile spread across my face as I typed a command into the terminal to run <code>httpd</code> in QEMU user mode, but after pressing the “Enter” key, I saw it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo chroot . ./qemu-armeb-static /usr/sbin/httpd -n
</span></span><span style=display:flex><span>cannot open /dev/nvram
</span></span></code></pre></div><p>Cannot open <code>/dev/nvram</code>. This error highlights a somewhat common obstacle when emulating embedded devices. Interacting with NVRAM can be an important step in the expected execution of an application, which can be made even more complicated when emulating a device.</p><h3 id=the-solution>The Solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h3><p>In this article, I’ll walk through one method that I used to hook into the functions that request and set data from <code>/dev/nvram</code>, enabling me to intercept and modify interactions with the NVRAM while my target application runs. This allows us to have more granular control of the values returned by calls to the NVRAM so that we can return our desired values. As a result, the application runs smoothly as though an NVRAM device actually existed on the system. Think of it like a man-in-the-middle attack on NVRAM that our target application is oblivious to.</p><p><em>Note: By &ldquo;target application&rdquo; or &ldquo;target binary&rdquo;, I am referring to the binary that is being emulated in QEMU and relies on the NVRAM. In my specific case, this is <code>httpd</code> in my extracted firmware.</em></p><p>This article aims to walk you through my thought process in approaching this rather than solely offering a copy-paste solution. I have found reading other researcher&rsquo;s thought processes to be helpful in the past and was hoping to pay it forward. As such, my troubleshooting steps and some of my (failed) ideas are included.</p><p><strong>TLDR;</strong> I built an instance of <a href=https://github.com/crosstool-ng/crosstool-ng>crosstool-ng</a> to create an <code>armeb-unknown-eabi</code> toolchain. This was necessary for me to cross-compile <a href=https://github.com/zcutlip/nvram-faker>nvram-faker</a> in the target architecture: big endian, 32-bit ARM. Nvram-faker allowed us to hijack function calls originally intended for libnvram.so, which is a library used to interface with <code>/dev/nvram</code>, through the <code>LD_PRELOAD</code> variable. I ended up patching <code>nvram-faker</code> in my <a href=https://github.com/ally-petitt/nvram-faker>own fork</a> to solve dynamic linking issues and solve a bug that caused a segfault.</p><h3 id=disclaimer>Disclaimer<a hidden class=anchor aria-hidden=true href=#disclaimer>#</a></h3><p>I am just a hobbyist. There are likely more efficient and/or robust ways to add support for NVRAM when emulating firmware with QEMU. This is just one of the solutions that I came across on my own. All the information in the article is accurate to the best of my knowledge and has the chance to be incorrect. I have done my best to fact-check the information presented.</p><p><img loading=lazy src=https://www.mouser.com/images/cypresssemiconductor/hd/tssop44.jpg alt="Picture of NVRAM"></p><h2 id=what-is-nvram>What is NVRAM?<a hidden class=anchor aria-hidden=true href=#what-is-nvram>#</a></h2><p>NVRAM, or non-volatile RAM, is a type of computer memory that maintains the values stored within it after the computer has been turned off and on again. Often, the NVRAM contains configuration information that can help direct applications during the boot process or runtime. It is almost like a Solid-State Drive (SSD), but with far less storage capacity, increased speed, and it is generally soldered onto the motherboard.</p><h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2><p>The following table shows a high-level overview of the firmware I am dealing with.</p><table><thead><tr><th>Architecture</th><th>ARMv5 (armeb)</th></tr></thead><tbody><tr><td>Chipset</td><td>IXP425</td></tr><tr><td>ABI</td><td>EABI5</td></tr><tr><td>Operating System</td><td>OpenWRT</td></tr><tr><td>Endianess</td><td>Big Endian</td></tr></tbody></table><p><strong>Goal:</strong> Run the binary <code>/usr/sbin/httpd</code> in our firmware image.</p><p><strong>Problem:</strong> <code>httpd</code> relies on NVRAM for configuration data. Since we are emulating in QEMU, we do not have the physical NVRAM to provide this data, so <code>httpd</code> is unable to initialize.</p><p><strong>Potential Solutions:</strong></p><ol><li>Create a custom kernel module to respond with the expected values at <code>/dev/nvram</code>.<ul><li>This can be more complex and would require reverse engineering of <code>libnvram.so</code> to understand how <code>/dev/nvram</code> expects to be interacted with in order to recreate the appropriate interface.</li><li>Building a specific implementation for this firmware may be less portable to other firmware images compared to our 2nd possible solution.</li></ul></li><li>Hook function calls to libnvram.so and override their return value.<ul><li>Potentially faster to implement.</li><li>There is already an open-source project called <a href=https://github.com/zcutlip/nvram-faker>nvram-faker</a> that can be used as a starting point.</li></ul></li></ol><p>Needless to say, I’ll be exploring solution 2 in this article. Although, I am open to creating the kernel module if it is requested since I can see if having educational value.</p><h2 id=nvram-faker>Nvram faker<a hidden class=anchor aria-hidden=true href=#nvram-faker>#</a></h2><p><a href=https://github.com/zcutlip/nvram-faker>Nvram-faker</a> is a GitHub project created by Zachary Cutlip in 2013 to &ldquo;intercept calls to libnvram when running embedded linux applications in emulated environments.&rdquo; Despite its old age, <code>Nvram-faker</code> is still very usable for today&rsquo;s use cases.</p><h3 id=how-it-works>How it Works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h3><p>Our <code>httpd</code> binary does not attempt to access <code>/dev/nvram</code>, the NVRAM device file in the firmware, directly. Instead, it uses a shared object file called <code>libnvram.so</code> in order to abstract interaction with NVRAM. This dependency on <code>libnvram.so</code> is evident in the &ldquo;About&rdquo; window on <code>httpd</code> in Ghidra.</p><p><img loading=lazy src=/images/nvram-1.png alt="Picture of linked libraries on the httpd binary">
<em>Yes, my Ghidra is in dark mode.</em></p><p>The <code>httpd</code> program imports functions like <code>nvram_get()</code> and <code>nvram_set()</code> from <code>libnvram.so</code> that manage interactions with <code>/dev/nvram</code>. If we were able to set our own definitions for what <code>nvam_get()</code> and <code>nvram_set()</code> do, we can effectively control the values that <code>httpd</code> receives when attempting to interact with the NVRAM through these functions.</p><p>That is what <code>nvram-faker</code> does. We can recreate the NVRAM-related procedures called by <code>httpd</code> in <code>nvram-faker.c</code> and compile them into our own library, <code>libnvram-faker.so</code>.</p><p>Furthermore, <code>httpd</code> dynamically links the <code>libnvram.so</code> library with the dynamic linker <a href=https://man7.org/linux/man-pages/man8/ld.so.8.html>ld</a>. By setting the environment variable <code>LD_PRELOAD</code> to <code>libnvram-faker.so</code>, <code>ld</code> is instructed to load our crafted shared object file before the real <code>libnvram.so</code> library is loaded in. Consequently, the NVRAM-related procedures that we defined in <code>nvram-faker.c</code> (and by extension <code>libnvram-faker.so</code>) will be called instead of the intended symbols in <code>libnvram.so</code>.</p><p><code>Nvram-faker</code> is programmed to parse through key-value pairs stored in a <code>/nvram.ini</code> file in the firmware squashfs root. When the target binary calls <code>nvram_get()</code>, the value defined in <code>/nvram.ini</code> for the requested key is returned.</p><h1 id=building-nvram-faker>Building Nvram-Faker<a hidden class=anchor aria-hidden=true href=#building-nvram-faker>#</a></h1><p>As previously mentioned, the firmware that I am emulating is big-endian, 32-bit ARM. Since <code>libnvram-faker.so</code> will be preloaded into a binary in that firmware, it must match that ARM architecture. This means that I will need to cross-compile our <code>nvram-faker</code>.</p><p>Cross-compiling requires a cross-compilation toolchain. ARM offers plenty of <a href=https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain>toolchains</a>, however, none of them matched what I was looking for, so I decided to use <a href=https://github.com/crosstool-ng/crosstool-ng>crosstool-ng</a> to compile my own toolchain. You can read their <a href=https://crosstool-ng.github.io/docs/>documentation</a> for more information on how this works.</p><h2 id=making-a-cross-compilation-toolchain-with-crosstool-ng>Making a Cross-Compilation Toolchain with Crosstool-ng<a hidden class=anchor aria-hidden=true href=#making-a-cross-compilation-toolchain-with-crosstool-ng>#</a></h2><p>I used the following commands to begin building <code>crosstool-ng</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install help2man libtool-bin <span style=color:#75715e>#dependencies</span>
</span></span><span style=display:flex><span>git clone https://github.com/crosstool-ng/crosstool-ng
</span></span><span style=display:flex><span>cd crosstool-ng
</span></span><span style=display:flex><span>git checkout tags/crosstool-ng-1.26.0
</span></span><span style=display:flex><span>./bootstrap
</span></span><span style=display:flex><span>./configure --prefix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>/build&#34;</span>
</span></span><span style=display:flex><span>make <span style=color:#f92672>&amp;&amp;</span> make install
</span></span></code></pre></div><p>With the created <code>ct-ng</code> binary, I began to configure my toolchain. Luckily, there was already a sample configuration from <code>armeb-unknown-eabi</code>, which is a match for my target architecture (I was able to tell based on the <a href=https://stackoverflow.com/questions/5731495/can-anyone-explain-the-gcc-cross-compiler-naming-convention/5731708#5731708>toolchain naming conventions</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./build/bin/ct-ng show-samples
</span></span><span style=display:flex><span>./build/bin/ct-ng show-armeb-unknown-eabi
</span></span><span style=display:flex><span>./build/bin/ct-ng armeb-unknown-eabi <span style=color:#75715e># load it into config</span>
</span></span><span style=display:flex><span>./build/bin/ct-ng menuconfig
</span></span></code></pre></div><p>I verified in the menu configuration that the settings for our target toolchain matched what I was expecting for this compilation in the “Target Options” menu.</p><p><img loading=lazy src=/images/nvram-2.png alt="Picture of the &amp;ldquo;Target Options&amp;rdquo; menu in the ct-ng menuconfig"></p><p>I later encountered difficulties with downloading the tarballs needed by <code>crosstool-ng</code>. To resolve this, I configured a mirror: <a href=https://ftp.gnu.org/gnu/>https://ftp.gnu.org/gnu/</a>.</p><p><img loading=lazy src=/images/nvram-5.png alt="Mirror added to menuconfig"></p><p>Future me experienced more errors relating to missing necessary C library header files. To address this, I enabled newlib.</p><p><img loading=lazy src=/images/nvram-6.png alt="Enabling the newlib C library in the ct-ng menuconfig"></p><p>We can now begin to build our target toolchain!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./build/bin/ct-ng build
</span></span></code></pre></div><p>The build process took about 40 minutes and eventually resulted in an error when attempting to compile <code>gdbserver</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>ERROR<span style=color:#f92672>]</span>    configure: error: C compiler cannot create executables
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>CFG  <span style=color:#f92672>]</span>    See <span style=color:#e6db74>`</span>config.log<span style=color:#960050;background-color:#1e0010>&#39;</span> <span style=color:#66d9ef>for</span> more details
</span></span></code></pre></div><p>I was worried that this error may have stopped the target toolchain from being created. I searched within the <code>.build</code> directory of <code>crosstool-ng</code> to check that the target binaries I was looking for were created.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find . -name <span style=color:#e6db74>&#39;*armeb-unknown-eabi*&#39;</span> -type f
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcc.1
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-tool.1
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov.1
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-cpp.1
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/share/man/man1/armeb-unknown-eabi-gcov-dump.1
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-tool
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ranlib
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-cpp
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-ar
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-nm
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcov-dump
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc-13.2.0
</span></span></code></pre></div><p>Perfect, the tools we need have been built. We can use the gdbserver built into QEMU for debugging. Let’s begin to compile nvram-faker.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/zcutlip/nvram-faker.git
</span></span><span style=display:flex><span>cd nvram-faker
</span></span><span style=display:flex><span>CC<span style=color:#f92672>=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make
</span></span></code></pre></div><p>Unfortunately, attempting to build nvram-faker with <code>make</code> resulted in two distinct errors. First, the file <code>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o</code> was not found.</p><p>Let’s investigate.</p><h2 id=troubleshooting-nvram-faker-compilation>Troubleshooting Nvram-Faker Compilation<a hidden class=anchor aria-hidden=true href=#troubleshooting-nvram-faker-compilation>#</a></h2><p>Since <code>make</code> appeared to expect <code>crt0.o</code> in a specific location, I figured that changing the search path to include the location that it was actually at would resolve the issue. I began by locating a copy of <code>crt0.o</code> that exists</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ find . -name <span style=color:#e6db74>&#39;crt0.o&#39;</span>
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o
</span></span></code></pre></div><p>Then, I used <code>$CFLAGS</code> such as <code>-I</code> and <code>-L</code> to include the path <code>./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/</code>. I also tried including the <code>crt0.o</code> file directly by manually using the <code>armeb-unkown-eabi-gcc</code> compiler with <code>crt0.o</code> as an input file, but neither of these worked.</p><p>I ultimately decided to copy <code>crt0.o</code> to the location that the cross-compiler was searching for it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir -p $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib
</span></span><span style=display:flex><span><span style=color:#75715e># the symlink didn&#39;t work</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ln -s ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/../../../../armeb-unknown-eabi/lib/crt0.o</span>
</span></span><span style=display:flex><span>cp ./.build/armeb-unknown-eabi/build/build-libc/armeb-unknown-eabi/newlib/crt0.o $HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/lib/gcc/armeb-unknown-eabi/13.2.0/crt0.o
</span></span></code></pre></div><p>Now that we&rsquo;ve solved the first error, let&rsquo;s move on to the next!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kali@kali:~/Documents/firmware/nvram-faker$ CC<span style=color:#f92672>=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc make
</span></span><span style=display:flex><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -ggdb -DINI_MAX_LINE<span style=color:#f92672>=</span><span style=color:#ae81ff>2000</span> -DINI_USE_STACK<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> -fPIC -c -o nvram-faker.o nvram-faker.c
</span></span><span style=display:flex><span>nvram-faker.c:1:10: fatal error: stdlib.h: No such file or directory
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> | <span style=color:#75715e>#include &lt;stdlib.h&gt;</span>
</span></span><span style=display:flex><span>      |          ^~~~~~~~~~
</span></span><span style=display:flex><span>compilation terminated.
</span></span><span style=display:flex><span>make: *** <span style=color:#f92672>[</span>Makefile:35: nvram-faker.o<span style=color:#f92672>]</span> Error <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>It seems that <code>make</code> was having difficulty with finding our C library. I ended up searching for the <code>stdlib.h</code> header file in the <code>crosstool-ng</code> directory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>~/Documents/firmware/crosstool-ng$ find . -name stdlib.h
</span></span><span style=display:flex><span>./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/stdlib.h
</span></span><span style=display:flex><span>./.build/src/gcc-13.2.0/fixincludes/tests/base/stdlib.h
</span></span><span style=display:flex><span>./.build/src/gcc-13.2.0/fixincludes/tests/base/ansi/stdlib.h
</span></span><span style=display:flex><span>./.build/src/gcc-13.2.0/libstdc++-v3/include/tr1/stdlib.h
</span></span><span style=display:flex><span>./.build/src/gcc-13.2.0/libstdc++-v3/include/c_compatibility/stdlib.h
</span></span><span style=display:flex><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/ssp/stdlib.h
</span></span><span style=display:flex><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/machine/stdlib.h
</span></span><span style=display:flex><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/stdlib.h
</span></span><span style=display:flex><span>./.build/src/newlib-4.3.0.20230120/newlib/libc/machine/powerpc/machine/stdlib.h
</span></span></code></pre></div><p>I first tried using the stdlib from <code>./.build/armeb-unknown-eabi/build/build-gdb-cross/gnulib/import/</code>, however, this resulted additional errors. My speculation is that the header files in there were intended for my host architecture, x64, and not the target architecture of 32-bit, big-endian ARM.</p><p>This was the point that I realized that rebuilding with newlib would solve this problem. This enabled me to include <code>./.build/src/newlib-4.3.0.20230120/newlib/libc/include/</code> as a search directory in our make command via the CFLAGS <code>-I</code> option:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> make CC<span style=color:#f92672>=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-I</span>$HOME<span style=color:#e6db74>/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib&#34;</span>
</span></span></code></pre></div><p>With that, our problems are solved.</p><h3 id=compiling-nvram-faker>Compiling nvram-faker.<a hidden class=anchor aria-hidden=true href=#compiling-nvram-faker>#</a></h3><p>Now that we are properly set up for building <code>nvram-faker</code>, let’s run <code>make</code> to create <code>libnvram-faker.so</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ make CC<span style=color:#f92672>=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-I</span>$HOME<span style=color:#e6db74>/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib&#34;</span>
</span></span><span style=display:flex><span>make: Nothing to be <span style=color:#66d9ef>done</span> <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;all&#39;</span>.
</span></span><span style=display:flex><span>$ file ./libnvram-faker.so 
</span></span><span style=display:flex><span>./libnvram-faker.so: ELF 32-bit MSB shared object, ARM, EABI5 version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>SYSV<span style=color:#f92672>)</span>, dynamically linked, with debug_info, not stripped
</span></span></code></pre></div><p>The <code>file</code> output is exactly what we want as it matches the other binaries executed on the firmware like busybox:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ file ./bin/busybox 
</span></span><span style=display:flex><span>./bin/busybox: ELF 32-bit MSB executable, ARM, EABI5 version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>SYSV<span style=color:#f92672>)</span>, dynamically linked, interpreter /lib/ld-musl-armeb.so.1, no section header
</span></span></code></pre></div><h3 id=using-nvram-faker>Using nvram-faker<a hidden class=anchor aria-hidden=true href=#using-nvram-faker>#</a></h3><p>Now, I’ll copy the libnvram-faker.so file and re-enter the chroot environment at the base of our firmware image’s squashfs file system.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cp ../../nvram-faker/libnvram-faker.so .
</span></span><span style=display:flex><span>touch nvram.ini
</span></span></code></pre></div><p>Let&rsquo;s test it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo chroot . ./qemu-armeb-static /bin/sh -c <span style=color:#e6db74>&#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&#34;</span>
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: __libc_init_array: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: main: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: __heap_limit: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: _impure_ptr: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: _ctype_: symbol not found
</span></span></code></pre></div><p>Hm, it looks like we have some more errors to resolve. Let’s understand why these are happening and address them. Based on the error message, I am going to assume that the linker was expecting the symbols above to be in our library (perhaps as some ABI standard?) and since they were not found, it has difficulty with determining where to place our library in memory. This is just a guess, so feel free to correct me if I’m wrong.</p><h3 id=troubleshooting-libnvram-fakerso>Troubleshooting libnvram-faker.so<a hidden class=anchor aria-hidden=true href=#troubleshooting-libnvram-fakerso>#</a></h3><p>I had two ideas that I thought may resolve this by including the expected symbols:</p><ol><li>Recompiling <code>libnvram-faker.so</code> with our cross-compiled <code>ld</code>, <code>ar</code>, <code>as</code>, <code>strip</code>, and <code>nm</code> binaries since I did not include these before.<ul><li>This operates on the assumption that including these binaries would automatically create the expected symbols.</li></ul></li><li>Manually patching <code>nvram-faker.c</code> to include the symbols that the linker is expecting.</li></ol><p>I started out testing the first idea.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ make clean
</span></span><span style=display:flex><span>rm *.o
</span></span><span style=display:flex><span>rm *.so
</span></span><span style=display:flex><span>rm nvram_faker_exe
</span></span><span style=display:flex><span>rm: cannot remove <span style=color:#e6db74>&#39;nvram_faker_exe&#39;</span>: No such file or directory
</span></span><span style=display:flex><span>make: <span style=color:#f92672>[</span>Makefile:46: clean<span style=color:#f92672>]</span> Error <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>ignored<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>make -C ./contrib/inih clean
</span></span><span style=display:flex><span>make<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>: Entering directory <span style=color:#e6db74>&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style=display:flex><span>rm *.o
</span></span><span style=display:flex><span>make<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>: Leaving directory <span style=color:#e6db74>&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ make CC<span style=color:#f92672>=</span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc CFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-I</span>$HOME<span style=color:#e6db74>/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include&#34;</span> LD<span style=color:#f92672>=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ld AR<span style=color:#f92672>=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-ar STRIP<span style=color:#f92672>=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-strip NM<span style=color:#f92672>=</span>$HOME/x-tools/armeb-unknown-eabi/bin/armeb-unknown-eabi-nm 
</span></span><span style=display:flex><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -Wall -I./contrib/inih -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o nvram-faker.o nvram-faker.c
</span></span><span style=display:flex><span>make -C ./contrib/inih ini.o
</span></span><span style=display:flex><span>make<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>: Entering directory <span style=color:#e6db74>&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style=display:flex><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -I$HOME/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include -fPIC -c -o ini.o ini.c
</span></span><span style=display:flex><span>make<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>: Leaving directory <span style=color:#e6db74>&#39;$HOME/Documents/firmware/nvram-faker/contrib/inih&#39;</span>
</span></span><span style=display:flex><span>cp ./contrib/inih/ini.o .
</span></span><span style=display:flex><span>$HOME/Documents/firmware/crosstool-ng/.build/armeb-unknown-eabi/buildtools/bin/armeb-unknown-eabi-gcc -shared -o libnvram-faker.so nvram-faker.o ini.o -Wl,-nostdlib
</span></span></code></pre></div><p>After copying it back to our squashfs root and trying again, it seems the same issue persists. This rules out incompatible <code>ld</code>, <code>ar</code>, <code>as</code>, <code>strip</code>, or <code>nm</code> binaries as the root cause. I wasn&rsquo;t confident that this would be the solution, but it was worth a shot. Now I know more.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cp ./libnvram-faker.so ../_extracted_firmware/squashfs-root/
</span></span><span style=display:flex><span>$ sudo chroot . ./qemu-armeb-static /bin/sh -c <span style=color:#e6db74>&#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&#34;</span>
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: initialise_monitor_handles: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: __libc_init_array: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: main: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: __libc_fini_array: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: __heap_limit: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: _impure_ptr: symbol not found
</span></span><span style=display:flex><span>Error relocating /libnvram-faker.so: _ctype_: symbol not found
</span></span></code></pre></div><p>Instead, let’s attempt the second idea. I created <a href=https://github.com/ally-petitt/nvram-faker>my own fork</a> of nvram-faker and got to work.</p><p>As I was creating the patch to manually add the expected symbols into <code>nvram-faker.c</code>, I made the observation that many of these symbols were defined in common C libraries like <code>ctypes.h</code> and <code>stdlib.h</code>. This made me suspect that the issue might reside in the flags relating to the C library.</p><p>I quickly tried recompiling without the <code>-nostdlib</code> flag by modifying the <code>nvram-faker</code> <code>Makefile</code> and recompiling with the <code>-static</code> flag. Neither of these worked, so I continued with the original plan, which involved appending the following to <code>nvram-faker.c</code> and recompiling:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>void main<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>	write<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;libnvram-faker.so has loaded\n&#34;</span>, 29<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void* initialise_monitor_handles;
</span></span><span style=display:flex><span>void* __heap_limit;
</span></span><span style=display:flex><span>void <span style=color:#f92672>(</span>*__libc_fini_array<span style=color:#f92672>[])</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>void <span style=color:#f92672>(</span>*__libc_init_array<span style=color:#f92672>[])</span> <span style=color:#f92672>(</span>void<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>struct _reent * _impure_ptr;
</span></span><span style=display:flex><span>char _ctype_;
</span></span></code></pre></div><p>I discovered the data types that work through a combination of compiler warnings and grepping for definitions such as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kali@kali:~/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include$ grep -r <span style=color:#e6db74>&#34;_ctype_&#34;</span> .
</span></span><span style=display:flex><span>./ctype.h:extern	__IMPORT const char	_ctype_<span style=color:#f92672>[]</span>;
</span></span></code></pre></div><p>Let’s try to run this again!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kali@kali:~/Documents/firmware/_extracted_firmware/squashfs-root$ sudo chroot . ./qemu-armeb-static /bin/sh -c <span style=color:#e6db74>&#34;LD_PRELOAD=/libnvram-faker.so /usr/sbin/httpd&#34;</span>
</span></span><span style=display:flex><span>cannot open /dev/nvram
</span></span><span style=display:flex><span>httpd : httpd cannot start. ssl and/or http must be selected
</span></span></code></pre></div><p>Well, our library loaded successfully this time, but it’s not quite what we were hoping for. From my prior reverse engineering of interesting libraries in this firmware, I knew that the error message we received comes from <code>libnvram.so</code>, which we can verify with grep.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ grep -r <span style=color:#e6db74>&#34;cannot open /dev/nvram&#34;</span> .
</span></span><span style=display:flex><span>Binary file ./lib/libnvram.so matches
</span></span></code></pre></div><h3 id=debugging-libnvram-fakerso>Debugging Libnvram-faker.so<a hidden class=anchor aria-hidden=true href=#debugging-libnvram-fakerso>#</a></h3><p>I wanted to get to the root of why this error message was still appearing despite using <code>libnvram-faker.so</code> to hook NVRAM-related functionality.</p><h4 id=attempt-1-gdb>Attempt 1: GDB<a hidden class=anchor aria-hidden=true href=#attempt-1-gdb>#</a></h4><p>I first attempted to debug using GDB. In QEMU, I used the built-in GDB server to listen on port 1234.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo chroot . ./qemu-armeb-static -g <span style=color:#ae81ff>1234</span> -E LD_PRELOAD<span style=color:#f92672>=</span>/libnvram-faker.so /usr/sbin/httpd
</span></span></code></pre></div><p>In another terminal window I modified my <code>.gdbinit</code> file to expedite the process of connecting and debugging to our target application.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat ~/.gdbinit
</span></span><span style=display:flex><span>set disassembly-flavor intel
</span></span><span style=display:flex><span>set print asm-demangle on
</span></span><span style=display:flex><span>source $HOME/Downloads/pwndbg/gdbinit.py
</span></span><span style=display:flex><span>set arch arm
</span></span><span style=display:flex><span>set follow-fork-mode child
</span></span><span style=display:flex><span>target extended-remote :1234
</span></span></code></pre></div><p>Then, I connected to the remote process.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gdb-multiarch ./usr/sbin/httpd
</span></span></code></pre></div><p><img loading=lazy src=/images/nvram-7.png alt="Pwndbg context output after connecting to the httpd debugging process"></p><p>To make debugging easier, I calculated the offset of the memory addresses in our debugging process to memory addresses in the <code>httpd</code> binary itself. When I ran the <code>load</code> command in GDB with this offset as the second parameter, it made the addresses in the debugger consistent with those in my Ghidra CodeBrowser.</p><p>To make this calculation, I subtracted PC (the ARM <a href=https://developer.arm.com/documentation/107656/0101/Registers/Registers-in-the-register-bank/R15--Program-Counter--PC->program counter register</a>) with the address of the first entry instruction in <code>httpd</code> to adjust our addresses to match that of the binary.</p><blockquote><p><details><summary markdown=span><strong>Note on verifying offset</strong></summary>I had verified that we were at the first entry instruction by matching the byte sequence that our PC was at (<code>x/3wx $PC</code>) to the hex dump of the <code>httpd</code> entrypoint (made easier through the use of a Ghidra search functionality).</details></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pwndbg&gt; load ./usr/sbin/httpd <span style=color:#ae81ff>4286266732</span>
</span></span></code></pre></div><p>This is where the problems with GDB began. There appeared to be an issue with the timing of the program between when I connected to the debugging process and it began execution. If the delay was more than a few milliseconds, the <code>libc_start_main</code> function would have a segmentation fault. I tried automating loading the program and setting breakpoints in <code>.gdbinit</code>, but even this was not fast enough to prevent a segfault.</p><p>I don’t know if there was a race condition or something else preventing normal execution. If anyone knows why this may have happened, please do let me know since I am quite puzzled by it.</p><p>I asked myself the question, “Is there another way to do this?”. I realized what I was really looking for was a call stack for when that error message was printed. I got an idea of how I could recreate this through static analysis.</p><h4 id=attempt-2-ghidra>Attempt 2: Ghidra<a hidden class=anchor aria-hidden=true href=#attempt-2-ghidra>#</a></h4><p>I started by pinpointing where our error message appears and checking its implementation in our fake NVRAM library.</p><p>In Ghidra, I opened a project with <code>libnvram.so</code> loaded in the CodeBrowser. Using the built-in tool <code>Window > Defined Strings</code>, I was able to search for our error message, “<code>cannot open /dev/nvram</code>."</p><p><img loading=lazy src=/images/nvram-8.png alt="Ghidra defined strings window showing our error message"></p><p>I followed the location of this string in the binary to reveal that it is referenced in a procedure that Ghidra called <code>FUN_00012420</code>.</p><p><img loading=lazy src=/images/nvram-9.png alt="The error message in the disassembly of the binary"></p><p>This function is called by some of the major functions in <code>libnvram.so</code> such as <code>nvram_get</code>.</p><p><img loading=lazy src=/images/nvram-10.png alt="The call tree of FUN_00012420"></p><p>When quickly listing the NVRAM functions imported in <code>httpd</code>(which there are defined strings for), it does not appear that <code>httpd</code> is calling a libnvram function that would trigger our error. However, that doesn’t mean that a call to this endpoint isn’t abstracted some other way.</p><p><img loading=lazy src=/images/nvram-11.png alt="Defined strings with &amp;ldquo;nvram&amp;rdquo; in them in <code>httpd</code>"></p><p>I decided to analyze a complete call graph of <code>FUN_00012420</code> (as opposed to the first layer of the call tree), which confirmed my suspicions: <code>nvram_set</code> called a function that called <code>FUN_00012420</code>. This means that <code>nvram_set</code>, a function called by <code>httpd</code>, was very likely the entrypoint to our “<code>cannot find /dev/nvram</code>” error message.</p><p><img loading=lazy src=/images/nvram-12.png alt="Call graph of FUN_00012420"></p><p>As stated in the <code>nvram-faker</code> <a href="https://github.com/zcutlip/nvram-faker?tab=readme-ov-file#using">README</a>:</p><blockquote><p>The library currently does not support calls to <code>nvram_set()</code>.</p></blockquote><p>My hypothesis was that since <code>nvram_set()</code> was not defined in the <code>libnvram-faker.so</code> library that we created, it was being imported from <code>libnvram.so</code>. In turn, <code>FUN_00012420</code> is called which attempts to open <code>/dev/nvram</code> and fails (since the kernel module for <code>/dev/nvram</code> does not exist), printing our error message.</p><p>To verify that this is the case, I once again patched <code>nvram-faker.c</code>, but this time I implemented a preliminary definition for <code>nvram_set</code> and observed whether the error from before is still present.</p><p>The following is what I added to <code>nvram-faker.c</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>char * nvram_set<span style=color:#f92672>(</span>char * key, char * value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	write<span style=color:#f92672>(</span>1, <span style=color:#e6db74>&#34;nvram_set called\n&#34;</span>, 17<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>After I compiled and ran <code>httpd</code>, this was my output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo chroot . ./qemu-armeb-static -E LD_PRELOAD<span style=color:#f92672>=</span>/libnvram-faker.so /usr/sbin/httpd
</span></span><span style=display:flex><span>nvram_set called
</span></span><span style=display:flex><span>httpd : httpd cannot start. ssl and/or http must be selected
</span></span></code></pre></div><p>Perfect! The previous error that <code>/dev/nvram</code> was not found is no longer appearing and in its place is the output that we injected for the <code>nvram_set()</code> function I defined. This verifies that <code>nvram_set</code> was the source of the error messages. Now, we can create our own implementation of <code>nvram_set</code> to enable full functionality of <code>httpd.</code></p><p>To streamline the development process, I made my own script to clean, build, and test the library:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e <span style=color:#75715e># exit on failure</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $# -ne <span style=color:#ae81ff>4</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Usage: </span>$0<span style=color:#e6db74> &lt;compilation_toolchain_binaries_path&gt; &lt;squashfs_root_path&gt; &lt;newlib_path&gt; &lt;target_binary_path&gt;&#34;</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Example: </span>$0<span style=color:#e6db74> </span>$HOME<span style=color:#e6db74>/x-tools/armeb-unknown-eabi/bin </span>$HOME<span style=color:#e6db74>/_extracted_firmware/squashfs-root </span>$HOME<span style=color:#e6db74>/Documents/firmware/crosstool-ng/.build/src/newlib-4.3.0.20230120/newlib/libc/include /usr/sbin/httpd&#34;</span>
</span></span><span style=display:flex><span>  exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TOOLCHAIN_PATH<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>SQUASHFS_PATH<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>NEWLIB_PATH<span style=color:#f92672>=</span>$3
</span></span><span style=display:flex><span>TARGET_BINARY<span style=color:#f92672>=</span>$4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make clean
</span></span><span style=display:flex><span>make CC<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>TOOLCHAIN_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>/armeb-unknown-eabi-gcc&#34;</span> CFLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-DDEBUG=1 -I</span><span style=color:#e6db74>${</span>NEWLIB_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> LD<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>TOOLCHAIN_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>/armeb-unknown-eabi-ld AR=</span><span style=color:#e6db74>${</span>TOOLCHAIN_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>/armeb-unknown-eabi-ar STRIP=</span><span style=color:#e6db74>${</span>TOOLCHAIN_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>/armeb-unknown-eabi-strip NM=</span><span style=color:#e6db74>${</span>TOOLCHAIN_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>/armeb-unknown-eabi-nm&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cp ./libnvram-faker.so <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>SQUASHFS_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>sudo chroot <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>SQUASHFS_PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> ./qemu-armeb-static -E LD_PRELOAD<span style=color:#f92672>=</span>/libnvram-faker.so <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>TARGET_BINARY<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>I encountered a segmentation fault when debug was enabled due to how <code>fprintf</code> was being used to log debug output through the <code>DEBUG_PRINTF</code> macro. I ended up redefining <code>DEBUG_PRINTF</code> and <code>LOG_PRINTF</code> to be based on <code>printf</code> instead of <code>fprintf</code> to prevent the segfault.</p><blockquote><p><details><summary markdown=span><strong>Expand to learn why fprintf was originally used instead of printf</strong></summary>After a bit of digging, I would discover that <code>fprintf()</code> was used for debug and log output in the original <code>nvram-faker</code> repository as a workaround to how <code>stdout</code> was being redirected after <code>system()</code> was called in the webserver it was used to emulate. As explained in the <a href=https://shadowfile.inode.link/blog/2015/01/patching-emulating-and-debugging-a-netgear-embedded-web-server/>author’s blogpost</a>, <code>fprintf()</code> allowed him to print to <code>stderr</code>, which was visible in the console, unlike the output of <code>printf()</code> that goes to <code>stdout</code> and was not visible after <code>system()</code> was called.</details></p></blockquote><h3 id=adding-support-for-nvram_set>Adding Support for nvram_set<a hidden class=anchor aria-hidden=true href=#adding-support-for-nvram_set>#</a></h3><p>It was originally my intention to add <code>nvram_set()</code> support to <code>nvram-faker.c</code> to fully mimic a real NVRAM interaction, however, an event came up in my personal life that delayed this. I may endeavor to do so in the future when the timing is better, however, for now I have opted to simply create my <a href=https://github.com/ally-petitt/nvram-faker>own fork</a> with the following improvements on the old one:</p><ul><li>More informative debug output</li><li>Resolve segmentation fault in debugging output</li><li>Added additional symbols to <code>nvram-faker.c</code> such as <code>initialise_monitor_handles</code> and <code>__libc_fini_array</code> to avoid linking errors</li><li>Add a preliminary <code>nvram_set()</code> function that logs debug output to prevent function calls to <code>libnvram.so</code></li><li>Add a <code>build_and_run.sh</code> script to streamline development and testing</li></ul><h2 id=next-steps>Next Steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h2><p>From here, you can simply create and populate an <code>nvram.ini</code> file at the root of your extracted firmware filesystem and add the keys-value pairs that your target application expects! There are many ways to figure out these expected values. For instance, you can run the target application and view the NVRAM values it requests in the debugging output. You can also reverse engineer the target application to see the values it expects.</p><p>Here is an excerpt from the <code>nvram-faker</code> example <a href=https://github.com/zcutlip/nvram-faker/blob/master/nvram.ini>nvram.ini</a> file for reference:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[config]
</span></span><span style=display:flex><span>os_name=linux
</span></span><span style=display:flex><span>os_version=1
</span></span><span style=display:flex><span>upnp_port=9999
</span></span><span style=display:flex><span>upnp_ad_time=30
</span></span><span style=display:flex><span>upnp_sub_timeout=60
</span></span><span style=display:flex><span>upnp_conn_retries=10
</span></span><span style=display:flex><span>log_level=10
</span></span><span style=display:flex><span>lan_hwaddr=52:54:00:12:34:58
</span></span><span style=display:flex><span>lan_ifname=eth0
</span></span><span style=display:flex><span>lan1_ifname=wlan0
</span></span></code></pre></div><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>This article was quite lengthy and technical compared to what I normally put out. It started as me wanting to test out a chroot sandbox on a router and escalated into emulating a webserver and needing a way to interface with NVRAM. This was a great exercise that taught me more about cross-compilation, NVRAM, and general troubleshooting. One year ago, I would have been overwhelmed by the amount of errors that I encountered while getting this to work (this article detailed less than half of them for brevity), so working through this helped to strengthen my perseverance as a researcher.</p><p>Overall, this was an interesting rabbit hole to go down. I hope it made as much sense in the text as it did in my head. If any details here are inaccurate, please feel free to contact me and I will be happy to correct the information in this article.</p><p>Thanks for reading!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ally-petitt.com:443/en/tags/firmware/>Firmware</a></li><li><a href=https://ally-petitt.com:443/en/tags/debugging/>Debugging</a></li></ul><nav class=paginav><a class=prev href=https://ally-petitt.com:443/en/posts/2024-12-25_rediscovering-cve-2024-48990-and-crafting-my-own-exploit/><span class=title>« Prev</span><br><span>Rediscovering CVE-2024-48990 and Crafting My Own Exploit</span>
</a><a class=next href=https://ally-petitt.com:443/en/posts/2024-05-07_how-i-became-a-hacker-before-i-finished-high-school/><span class=title>Next »</span><br><span>How I became a hacker before I finished high school [Repost]</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on x" href="https://x.com/intent/tweet/?text=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device&amp;url=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f&amp;hashtags=Firmware%2cDebugging"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f&amp;title=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device&amp;summary=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device&amp;source=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f&title=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on whatsapp" href="https://api.whatsapp.com/send?text=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device%20-%20https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on telegram" href="https://telegram.me/share/url?text=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device&amp;url=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How to Use NVRAM When Emulating an Embedded Device on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20to%20Use%20NVRAM%20When%20Emulating%20an%20Embedded%20Device&u=https%3a%2f%2fally-petitt.com%3a443%2fen%2fposts%2f2024-07-05_emulating-with-nvram%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://ally-petitt.com:443/en/>Ally Petitt</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>